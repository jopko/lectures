# 6. массивы и перечисления 

Содержание

1. массивы
	+ Описание
	+ Инициализация
	+ Доступ к элементам
	+ Строки символов
	+ Приёмы обработки
	+ Указатели и массивы
2. Перечисления
	+ Описание
	+ Пример использования
3. Объединения


## ## массивы

Как и в большинстве других языков программирования, в Си под массивом понимается совокупность однородных данных, рассматриваемых как нечто единое. Математическими аналогами программистского понятия массив является, например, матрица, которая в программе задается в виде двухмерного массива, или вектор, задаваемый одномерным массивом. Массив это такой объект программы, который характеризуется именем, размерностью, количеством элементов по каждому измерению и типом значений его элементов.




###	Описание массивов

	<тип> <имя>[<размер1>][<размер2>]...[<размерN>];

`<тип>` определяет тип элементов массива;

`<имя>` – это <идентификатор>, задающийся по усмотрению программиста и являющийся именем массива. Имя массива используется для доступа к элементам массива;

`<размер>` определяет количество элементов массива по каждому измерению и записывается целой беззнаковой константой.

пример:
```C
	int v[120];		//одномерный массив из 120-ти целых чисел;
	float mt[7][9];	//двумерный массив из 7x9=63 чисел с плавающей точкой;
	char str[25];	//массив из 25-ти символов;
	char *u[10];	//массив указателей на объекты типа char;
	int *pr[2][3];	//двухмерный массив из 2х3=6 указателей на целые данные;
	int (*r)[5][6];	//указатель на данные целого типа,
					//сгруппированные в массивы 5*6,
					//самих данных может даже не быть.
```
Доступ к элементу массива обеспечивается использованием имени массива, вслед за которым в квадратных скобках записываются координаты элемента (индексы) по соответствующим измерениям. Элементы многомерного массива отображаются в линейной памяти одномерным массивом, своеобразной построчной разверткой.

пример:
```C
	int vect[10], k;
	for(k = 0; k <= 9; k++)
		vect[k] = k;
```


### Инициализация массивов

пример:
```C
	int num[2]={1,3}; -> 	num[0]=1; num[1]=3;
```

При описании массивов с инициализацией элементов не обязательно указывать размеры массива. Компилятор сам определит количество элементов и выделит для них память соответствующего размера.
Недостающие при инициализации значения принимаются равными нулю

пример:
```C
	char text[] = {"hello"};
	int vector[3] = {86, 2};
```
Инициализация многомерного массива похожа на сбор матрешки. Имеем как бы несколько массивов вложеных друг в друга. Но ничего не мешает развертывать многомерный массив построчно, как будто это линейный массив.

пример:
```C
	char buf [] =        {  };
	char buf [][] =     {{  }, {  }, {  }};
	char buf [][][] = { {{  }, {  }, {  }},
						{{  }, {  }, {  }},
						{{  }, {  }, {  }} };
	char buf [][][] =    {  };
```

### Доступ к элементам массива

1. Использование индексированной переменной. Это наиболее естественный, простой и понятный способ доступа к элементам массива любой размерности.

	пример:
	```C
		mas[n] = 0x1;
	```
	Использованный в исходной программе способ обращения к элементу массива на самом деле заменяется компилятором на обращение через указатель – имя массива. Отсюда становится понятным, почему в Си нумерация индексов массива начинается с нуля.

2. Использование имени одномерного массива. Этот способ доступа к элементам массива основан на том, что в Си имя одномерного массива трактуется как константа-указатель на данные, тип которых определен типом элементов массива, а значением этой константы является адрес нулевого элемента.
Следовательно, применив к имени массива операции адресной арифметики, можно получить доступ к любому элементу массива.

	пример:
	```C
		*(mas + n) = 0x1;
	```
3. Доступ к элементам многомерных массивов. Многомерный массив трактуется как одномерный массив массивов.

	пример:
	```C
		int m[2][3][2] = {	{					//m[0]
							{ 10, 11 },		//m[0][0]
							{ 12, 13 },		//m[0][1]
							{ 14, 15 }		//m[0][2]
						},
						{					//m[1]
							{ 16, 17 },		//m[1][0]
							{ 18, 19 },		//m[1][1]
							{ 20, 21 }		//m[1][2]
						}
					};
		m[1][2][3]		//значение элемента m[1][2][3]
		*(m[1][2]+ 3)
	```
4. Доступ через переменную указатель. К элементам массива можно обратиться при помощи вспомогательного указателя. Для этого необходимо описать указатель с типом, соответствующим типу массива, и присвоить ему значение имени массива, которое является константой типа указатель. Теперь с указателем можно манипулировать как с переменной, ссылающейся на элементы массива, над ней можно выполнять любые действия, допустимые в адресной арифметике.

	пример:
	```C
		int arr[2][3] = {1,2,3,4,5,6}; 	// {{1,2,3}, {4,5,6}};
		int *p = arr;
		p +=3;	//a[0][3]
		p +=4;	//a[1][4]
	```
	надо учитывать , что указатель "передвигается" по данным в той последовательности, в какой они расположены в памяти. Если, увеличивая указатель, мы выйдем за пределы данных массива, то он будет указывать на неопределенные данные.


### Строки символов

Cимвольная строка в Си есть не что иное, как массив символов, последним символом которого является нуль-символ – признак конца строки. Для нуль-символа также надо зарезервировать место в массиве. Размер массива можно задавать и явно.

пример:
```C
	char text[]= "строка";
	char text[]= {'с','т','р','о','к','а','\0'};
	char text[10]= {'с','т','р','о','к','а','\0','\0','\0','\0'};
```
При обработке нескольких строк удобно организовать для их хранения массив символьных строк.

пример:
```C
	char m[][10]={
		"строка",
		"string",
		"characters",
		"символы"
	}
```

Двухмерный массив можно трактовать как одномерный массив, элементами которого являются другие одномерные массивы.

пример:
```C
	char *pstring[]={
		"строка",
		"string",
		"characters",
		"символы"
	}
```
В отличие от массива символьных строк, здесь строки не дополняются нуль-символами для достижения одинаковой длины, а занимают столько места в памяти, сколько в них символов плюс нуль-символ.


###	Приёмы обработки массива

пример:
```C
	//Упорядочивание числового массива по возрастанию значений элементов:

	#include <stdio.h>
	#define razmer 12
	main() {
		int s,p,i;
		int massiv [razmer] = {11,10,9,8,7,6,5,4,3,2,1,0};

		for (p =razmer; p >=2; p--)
		fоr (i =0; i <p-1; i++)
			if (massiv[i] > massiv[i+1]) {    // Доступ к элементам
				s = massiv[i+1];              // через переменную
				massiv[i+1] = massiv[i];      // с индексом.
				massiv[i] = s;
			};
		for(i =0; i <razmer; i++)             // Печать отсортированного массива
			printf("%d ",*(massiv+i));        // Доступ через имя массива
	}

	// Результат работы программы:
	// 0 1 2 3 4 5 6 7 8 9 10 11
```
пример: Упорядочивание строк по алфавиту
```C
	char str[][32] = {
		"Чехов А. Ионыч",
		"Толстой Л. Детство",
		"Достоевский Ф. Братья Карамазовы"
	}
```

### Указатели и массивы

В Си существует связь между указателями и массивами. Любой доступ к элементу массива, осуществляемый операцией индексирования, может быть выполнен с помощью указателя.

пример:
```C
	int a[10];		//определяем массив
	int *pa = a;	//указатель на int
	a[i]			//отсылка к i элементу массиву
	pa[i]
	*(pa+i)
	*(а+i)
```
Вычисляя `а[i]`, Си сразу преобразует его в `*(a+i)`

Между именем массива и указателем, выступающим в роли имени массива, существует одно различие. Указатель — это переменная, поэтому можно написать `ра=а` или `ра++`. Но имя массива не является переменной, это скорее константа, и записи вроде `а=ра` или `а++` не допускаются.

Если имя массива передается функции, то последняя получает в качестве аргумента адрес его начального элемента. Внутри вызываемой функции этот аргумент является локальной переменной, содержащей адрес.

пример:
```C
	int strlen (char *s) { 			//возвращает длину строки
		int n;
		for (n = 0; *s != '\0' ; s++)
			n++;
		return n;
	}
```
переменная `s` — указатель, к ней применима операция `++`; `s++` не оказывает никакого влияния на строку символов функции, которая обратилась к `strlen`. Просто увеличивается на 1 некоторая копия указателя, находящаяся в личном пользовании функции `strlen`. 


## ## Перечисления

### Описание

Перечисление – это конструируемый тип данных, во время описания которого задается имя типа данных и значения, которые могут принимать переменные этого типа.

	enum <имя_типа> {<список_значений>}<список_переменных>;

`<имя_типа>` задается идентификатором Си по усмотрению программиста;

`<список_значений>` задается в виде: <элемент1>, <элемент2>,...,<элементN>, где любой из элементов есть либо <имя>, либо <имя> = <константное_выражение>.

`<список_переменных>` – это список имен переменных типа перечисление, отделенные друг от друга запятой.

пример:
```C
	enum Boolean {FALSE =0, TRUE =1} flag1, flag2;
	enum Boolean foo;
	enum Day {SATURDAY, SUNDAY =0, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY} workday;
	enum Day nextday, today = MONDAY;
```
по сути создаются именованные константы, значения которым присваивается автоматически и ничто не запрещает использовать их как обычные целочисленные константы

пример:
```C
	char day =0;
	day += MONDAY;
```

### Пример использования

Предположим, нам необходимо написать фрагмент программы, который будет определять, образуют ли растворимую или нерастворимую в воде соль заданные кислота и металл.
```C
	main() {
		enum Metall {K,Na,Mg,Fe,Co,Zn,Cu,Pb,Ag} met;
		enum Acid {HCl,HNO3,H2SO4,H3PO4,H2CO3} acd;

		if (met < Pb) {
			if (acd < H3PO4)		"растворимая"
			else {
				if (met > Mg)		"нерастворимая"
				else				"растворимая"
			}
		}
		else if (met > Pb)			"нерастворимая"
		else { //met == Pb
			if (acd > HNO3)			"нерастворимая"
			else if (acd == HNO3)	"растворимая"
			else					"малорастворимая"
		}
	}
```









след. лекция [[в начало](README.md)]
















