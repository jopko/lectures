Массивы
	Как и в большинстве других языков программирования, в Си под массивом понимается совокупность однородных данных, рассматриваемых как нечто единое. Математическими аналогами программистского понятия массив является, например, матрица, которая в программе задается в виде двухмерного массива, или вектор, задаваемый одномерным массивом. Массив это такой объект программы, который характеризуется именем, размерностью, количеством элементов по каждому измерению и типом значений его элементов.




	7.2.1. Описание массивов

		<тип> <имя>[<размер1>][<размер2>]...[<размерN>];

		<тип> определяет тип элементов массива;
		<имя> – это <идентификатор>, задающийся по усмотрению программиста и являющийся именем массива. Имя массива используется для доступа к элементам массива;
		<размер> определяет количество элементов массива по каждому измерению и записывается целой беззнаковой константой.

		пример:
			int v[120];		//v – одномерный массив из 120-ти целых чисел;
			float mt[7][9];	//mt – двумерный массив из 7x9=63 чисел с плавающей точкой;
			char str[25];	//str – массив из 25-ти символов;
			char *u[10];	//u – массив указателей на объекты типа char;
			int *pr[2][3];	//pr – двухмерный массив из 2х3=6 указателей на целые данные;
			int (*r)[5][6];	//r – указатель на данные целого типа, сгруппированные в массивы 5*6;
							//обратите внимание, что r в данном случае не является массивом.

		Доступ к элементу массива обеспечивается использованием имени массива, вслед за которым в квадратных скобках записываются координаты элемента (индексы) по соответствующим измерениям. Элементы многомерного массива отображаются в линейной памяти одномерным массивом, своеобразной построчной разверткой.

		пример:
			int vect[10], k;
			for(k = 0; k <= 9; k++)
				vect[k] = k;



	7.2.2. Инициализация массивов
		пример:
			int num[2]={1,3}; -> 	num[0]=1; num[1]=3;

		При описании массивов с инициализацией элементов не обязательно указывать размеры массива. Компилятор сам определит количество элементов и выделит для них память соответствующего размера.
		Недостающие при инициализации значения принимаются равными нулю

		пример:
			char text[] = {"hello"};
			int vector[3] = {86, 2};

		Инициализация многомерного массива похожа на сбор матрешки. Имеем как бы несколько массивов вложеных друг в друга. Но ничего не мешает развертывать многомерный массив построчно, как будто это линейный массив.

		пример:
			char buf [] =        {  };
			char buf [][] =     {{  }, {  }, {  }};
			char buf [][][] = { {{  }, {  }, {  }},
								{{  }, {  }, {  }},
								{{  }, {  }, {  }} };
			char buf [][][] =    {  };

	7.2.3. Доступ к элементам массива

		1. Использование индексированной переменной. Это наиболее естественный, простой и понятный способ доступа к элементам массива любой размерности.

		пример:
			mas[n] = 0x1;

		Использованный в исходной программе способ обращения к элементу массива на самом деле заменяется компилятором на обращение через указатель – имя массива. Отсюда становится понятным, почему в Си нумерация индексов массива начинается с нуля.

		2. Использование имени одномерного массива. Этот способ доступа к элементам массива основан на том, что в Си имя одномерного массива трактуется как константа-указатель на данные, тип которых определен типом элементов массива, а значением этой константы является адрес нулевого элемента.
		Следовательно, применив к имени массива операции адресной арифметики, можно получить доступ к любому элементу массива.

		пример:
			*(mas + n) = 0x1;

		3. Доступ к элементам многомерных массивов. Многомерный массив трактуется как одномерный массив массивов.

		пример:
		int m[2][3][2] = {	{					//m[0]
								{ 10, 11 },		//m[0][0]
								{ 12, 13 },		//m[0][1]
								{ 14, 15 }		//m[0][2]
							},
							{					//m[1]
								{ 16, 17 },		//m[1][0]
								{ 18, 19 },		//m[1][1]
								{ 20, 21 }		//m[1][2]
							}
						};
		m[1][2][3]		//значение элемента m[1][2][3]
		*(m[1][2]+ 3)

		4. Доступ через переменную указатель. К элементам массива можно обратиться при помощи вспомогательного указателя. Для этого необходимо описать указатель с типом, соответствующим типу массива, и присвоить ему значение имени массива, которое является константой типа указатель. Теперь с указателем можно манипулировать как с переменной, ссылающейся на элементы массива, над ней можно выполнять любые действия, допустимые в адресной арифметике.

		пример:
			int arr[2][3] = {1,2,3,4,5,6}; 	// {{1,2,3}, {4,5,6}};
			int *p = arr;
			p +=3;	//a[0][3]
			p +=4;	//a[1][4]

		надо учитывать , что указатель "передвигается" по данным в той последовательности, в какой они расположены в памяти. Если, увеличивая указатель, мы выйдем за пределы данных массива, то он будет указывать на неопределенные данные.



	7.2.4. Строки символов
	Cимвольная строка в Си есть не что иное, как массив символов, последним символом которого является нуль-символ – признак конца строки. Для нуль-символа также надо зарезервировать место в массиве. Размер массива можно задавать и явно.

	пример:
		char text[]= "строка";
		char text[]= {'с','т','р','о','к','а','\0'};
		char text[10]= {'с','т','р','о','к','а','\0','\0','\0','\0'};

	При обработке нескольких строк удобно организовать для их хранения массив символьных строк.
	пример:
		char m[][10]={
			"строка",
			"string",
			"characters",
			"символы"
		}

	Двухмерный массив можно трактовать как одномерный массив, элементами которого являются другие одномерные массивы.
	пример:
		char *pstring[]={
			"строка",
			"string",
			"characters",
			"символы"
		}
	В отличие от массива символьных строк, здесь строки не дополняются нуль-символами для достижения одинаковой длины, а занимают столько места в памяти, сколько в них символов плюс нуль-символ.


	7.2.5. Приёмы обработки массива

	пример: Упорядочивание числового массива по возрастанию значений элементов:

		#include <stdio.h>
		#define razmer 12
		main() {
			int s,p,i;
			int massiv [razmer] = {11,10,9,8,7,6,5,4,3,2,1,0};

			for (p =razmer; p >=2; p--)
			fоr (i =0; i <p-1; i++)
				if (massiv[i] > massiv[i+1]) {    // Доступ к элементам
					s = massiv[i+1];              // через переменную
					massiv[i+1] = massiv[i];      // с индексом.
					massiv[i] = s;
				};
			for(i =0; i <razmer; i++)             // Печать отсортированного массива
				printf("%d ",*(massiv+i));        // Доступ через имя массива
		}

		//Результат работы программы:
		0 1 2 3 4 5 6 7 8 9 10 11

	пример: Упорядочивание строк по алфавиту
		char str[][32] = {
			"Чехов А. Ионыч",
			"Толстой Л. Детство",
			"Достоевский Ф. Братья Карамазовы"
		}





Перечисления
	7.3.1. Описание
	Перечисление – это конструируемый тип данных, во время описания которого задается имя типа данных и значения, которые могут принимать переменные этого типа.

		enum <имя_типа> {<список_значений>}<список_переменных>;

	<имя_типа> задается идентификатором Си по усмотрению программиста;
	<список_значений> задается в виде: <элемент1>, <элемент2>,...,<элементN>, где любой из элементов есть либо <имя>, либо <имя> = <константное_выражение>.
	<список_переменных> – это список имен переменных типа перечисление, отделенные друг от друга запятой.

	пример:
		enum Boolean {FALSE =0, TRUE =1} flag1, flag2;
		enum Boolean foo;
		enum Day {SATURDAY, SUNDAY =0, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY} workday;
		enum Day nextday, today = MONDAY;

	по сути создаются именованные константы, значения которым присваивается автоматически и ничто не запрещает использовать их как обычные целочисленные константы

	пример:
		char day =0;
		day += MONDAY;


	7.3.2. Пример использования
	Предположим, нам необходимо написать фрагмент программы, который будет определять, образуют ли растворимую или нерастворимую в воде соль заданные кислота и металл.

	main() {
		enum Metall {K,Na,Mg,Fe,Co,Zn,Cu,Pb,Ag} met;
		enum Acid {HCl,HNO3,H2SO4,H3PO4,H2CO3} acd;

		if (met < Pb) {
			if (acd < H3PO4)		"растворимая"
			else {
				if (met > Mg)		"нерастворимая"
				else				"растворимая"
			}
		}
		else if (met > Pb)			"нерастворимая"
		else { //met == Pb
			if (acd > HNO3)			"нерастворимая"
			else if (acd == HNO3)	"растворимая"
			else					"малорастворимая"
		}
	}



























