5 Указатели и массивы 93
5.1 Указатели и адреса 93
5.2 Указатели и аргументы функций 94
5.3 Указатели и массивы 96
5.4 Адресная арифметика 99
5.5 Символьные указатели функции 102
5.6 Массивы указателей, указатели на указатели 105
5.7 Многомерные массивы 108
5.8 Инициализация массивов указателей 110
5.9 Указатели против многомерных массивов 110
5.10 Аргументы командной строки 111
5.11 Указатели на функции 115
5.12 Сложные объявления 118


5 Указатели и массивы 93
	Указатель — это переменная, содержащая адрес переменной. Указатели широко применяются в Си — отчасти потому, что в некоторых случаях без них просто не обойтись, а отчасти потому, что программы с ними обычно короче и эффективнее.
	Наряду с goto указатели когда-то были объявлены лучшим средством для написания малопонятных программ.


5.1 Указатели и адреса 93
	Рассмотрим упрощенную схему организации памяти. Память типичной машины представляет собой массив последовательно пронумерованных или проадресованных ячеек, с которыми можно работать по отдельности или связными кусками.

	А) Унарный оператор & выдает адрес объекта
	р = &с;
	переменной p присваивается адрес ячейки c (говорят, что р указывает на с). Оператор & применяется только к объектам, расположенным в памяти: к переменным и элементам массивов. Его операндом не может быть ни выражение, ни константа, ни регистровая переменная.

	Б) Унарный оператор * есть оператор косвенного доступа. Примененный к указателю, он выдает объект, на который данный указатель указывает.

	пример:
		int х = 1, у = 2, z[10];
		int *ip;		//ip - указатель на int
		ip = &x;		//теперь ip указывает на х
		y = *ip;		//у теперь равен 1
		*ip = 0;		//х теперь равен 0
		ip = &z[0];		//ip теперь указывает на z[0]

	Если указатель *ip указывает на x , то *ip можно использовать в любом месте, где допустимо применение х.

	пример:
		*ip = *ip+ 10;

	Унарные операторы * и & имеют более высокий приоритет, чем арифметические операторы, так что присваивание. Но унарные операторы * и ++ имеют одинаковый приоритет и порядок выполнения — справа налево.

	пример:
		у = *ip + 1
		*ip += 1
		(*ip)++
		*ip++ 		//увеличится значение самого указателя

	И наконец, так как указатели сами являются переменными, в тексте они могут встречаться и без оператора косвенного доступа.

	пример:
		iq = ip




5.2 Указатели и аргументы функций 94
	Функции в Си в качестве своих аргументов получают значения параметров, нет прямой возможности, находясь в вызванной функции, изменить переменную вызывающей функции. Аргументы-указатели позволяют функции осуществлять доступ к объектам вызвавшей ее программы и дают возможность изменить эти объекты.

	пример:
		void swap (int x, int y) { 		//неверно
			int temp;
			temp = x;
			x = y;
			y = temp;
		}
		void swap (int *px, int *py) {	//верно
			int temp;
			temp = *рх;
			*рх = *py;
			*рy = temp;
		}
		swap(&a, &b);					//использование

	Так как оператор & получает адрес переменной, &a есть указатель на a. В самой же функции swap параметры должны быть объявлены как указатели, при этом доступ к значениям параметров будет осуществляться косвенно.






5.3 Адресная арифметика 99
	Под адресной арифметикой понимаются действия над указателями, связанные с использованием адресов памяти. Рассмотрим операции, которые можно применять к указателям, попутно заметив, что некоторые из них уже рассматривались, однако здесь мы повторимся, для систематизации изложения материала.

	Соединение указателей, массивов и адресной арифметики — одна из сильных сторон Си. Для операций над указателями их нужно сначала инициализировать осмысленными значениями.

	5.3.1 Инициализация.
		Первый способы:
			Описать переменные программы. Поскольку компилятор отводит память под переменную в момент ее описания, то присваивание указателю адреса переменной гарантирует, что нужная память отведена и там будут находиться значения переменных.
			пример:
				float a;
				float *p = &a;

				char buf[10];
				char *p;
				p = buf;
				p = &buf[4];
		Второй:
			присвоить указателю значение другого указателя, к этому моменту уже правильно инициализированного.
			пример:
				float *i = p;
		Третий:
			использовать одну из встроенных функции распределения памяти.
			пример:
				#include <stdio.h>
				#include <stdlib.h>
				void main() {
					int *b =  malloc (10*sizeof(int));
					if (b == 0){
						//error, память не выделилась
					}else{
						int i;
						for (i=0; i< 10; i++)
							printf("0x%x\n", &b[i]);
					}
				}

		другие примеры:
			char *p, *pp;
			char buf[10];
			int array[8];
			p = buf;
			p = &buf[4];
			p = 0x0;
			p = 0xE040;			//error
			p = (char*) 0x4100;
			p = array;			//error
			p = pp;


	5.3.2 Операции.
		1. Присваивание. Указателю можно присвоить значение адреса. Любое число, присвоенное указателю, трактуется как адрес памяти:
			пример:
				int *u,*adr;
				int N;
				u = &N;					//указателю присвоен адрес переменной N
				adr = (int *)0х00FD;	//указателю присвоен 16-теричный адрес

		2. Взятие адреса. Так как указатель является переменной, то для получения адреса памяти, где расположен указатель, можно использовать операцию взятия адреса &
			пример:
				int *a,*b;
				a = &b;					//указателю a присвоен адрес указателя b

		3. Косвенная адресация. Для того, чтобы получить значение, хранящееся по адресу, на который ссылается указатель, или послать данное по адресу, используется операция косвенной адресации *
			пример:
				int *p, n, m = 5;
				p = &m;					//адрес переменной m
				n = *p;					//переменная n принимает значение m
				*p = -13;				//переменная m принимает значение -13

		4. Преобразование типа. Указатель на объект одного типа может быть преобразован в указатель на другой тип. При этом следует учитывать, что объект, адресуемый преобразованным указателем, будет интерпретироваться по-другому. Операция преобразования типа указателя применяется в виде (<тип> *)<указатель>
			пример:
				int i, a, *ptr;
				i = 0x8e41;
				ptr = &i;
				a = *ptr;				//a = 0x8e41
				a = *((char *)ptr);		//a = 0x41
		Преобразование типа указателя чаще всего применяется для приведения указателя на неопределенный тип данных void к типу объекта, доступ к которому будет осуществляться через этот указатель.


		5. Определение размера. Для определения размера указателя можно использовать операцию размер в виде sizeof(<указатель>). Размер памяти, отводимой компилятором под указатель, зависит от модели памяти. Для близких указателей операция sizeof дает значение 2(байт), для дальних 4(байт).
			пример:
				type *p
				sizeof(*p) = sizeof(type)	//результат равен размеру типа переменной
				sizeof(p) = sizeof(address)	//результат равен разрядности шины адреса системы

		6. Сравнение. Сравнение двух указателей любой из операций отношения имеет смысл только в том случае, если оба указателя адресуют общий для них объект, например, строку или массив.
			пример:
				pbuf = buf[4];
				ptr = 0xE450;
				if (pbuf > ptr) ..  	//результат сравнения непредсказуем (true\false?)

		7. Индексация. Указатель может индексироваться применением к нему операции индексации, обозначаемой в Си квадратными скобками [ ]. Индексация указателя имеет вид <указатель>[<индекс>], где <индекс> записывается целочисленным выражением.
		Возвращаемым значением операции индексации является данное, находящееся по адресу, смещенному в большую или меньшую сторону относительно адреса, содержащегося в указателе в момент применения операции. Этот адрес определяется так: (адрес в указателе) + (значение <индекс>) * sizeof(<тип>).
			пример:
				char *ptext;
				ptext[2] = ' ';			//ptext + 2*sizeof(char) = ptext + 2*1

		8. Сложение\Вычитание. Одним из операндов операции может быть указатель, а другим операндом обязательно должно быть выражение целого типа. Операция вырабатывает адрес, который определяется следующим образом:  (адрес в указателе) + (значение int_выражения)*sizeof(<тип>), где <тип> это тип данных, на которые ссылается указатель.
			пример:
				double *pd;
				pd += 4;		//адрес увеличится на 4*sizeof(double) = 4*8 = 32, не на 4!

		9. Увеличение/уменьшение. Если к указателю применяется операция увеличения ++ или уменьшения --, то значение указателя увеличивается или уменьшается на размер объекта, который он адресует. Упрощенный вариант предыдущего пункта.
			пример:
				long long int ax, *p;
				p = &ax;				//адрес переменной ax
				p++;					//адрес увеличится на sizeof(ax), т.е. на 8, не на 1!
				p--;

				char text[] = "hello";	//текстовый массив
				char *s = text;			//адрес текстового массива
				s++;					//адрес увеличится на sizeof(char), т.е. на 1

		пример сознательного обхода адресной арифметики.
			int n, *p;
			p = (long)(p) + n;	//преобразуем указатель в обычное число и делаем что хотим



5.4 Указатели и массивы 96
	В Си существует связь между указателями и массивами. Любой доступ к элементу массива, осуществляемый операцией индексирования, может быть выполнен с помощью указателя.

	пример:
		int a[10];		//определяем массив
		int *pa = a;	//указатель на int
		a[i]			//отсылка к i элементу массиву
		pa[i]
		*(pa+i)
		*(а+i)

	Вычисляя а[i], Си сразу преобразует его в *(a+i)

	Между именем массива и указателем, выступающим в роли имени массива, существует одно различие. Указатель — это переменная, поэтому можно написать ра=а или ра++. Но имя массива не является переменной, это скорее константа, и записи вроде а=ра или а++ не допускаются.

	Если имя массива передается функции, то последняя получает в качестве аргумента адрес его начального элемента. Внутри вызываемой функции этот аргумент является локальной переменной, содержащей адрес.

	пример:
		int strlen (char *s) { 			//возвращает длину строки
			int n;
			for (n = 0; *s != '\0' ; s++)
				n++;
			return n;
		}
	переменная s — указатель, к ней применима операция ++; s++ не оказывает никакого влияния на строку символов функции, которая обратилась к strlen. Просто увеличивается на 1 некоторая копия указателя, находящаяся в личном пользовании функции strlen.


//5.5 Символьные указатели функции 102
5.6 Массивы указателей, указатели на указатели 105
5.7 Многомерные массивы 108
5.8 Инициализация массивов указателей 110
5.9 Указатели против многомерных массивов 110
5.10 Аргументы командной строки 111
5.11 Указатели на функции 115
5.12 Сложные объявления 118