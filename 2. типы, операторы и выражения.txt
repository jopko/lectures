2. Типы, операторы и выражения

Переменные и константы являются основными объектами данных, с которыми имеет дело программа. Своеобразные "кирпичики".




2.1 Имена переменных
	существуют некоторые ограничения на задание имен переменных и именованных констант. Имена составляются из букв и цифр; первым символом должна быть буква. Символ подчеркивания "_" считается буквой. Соглашения об именах, разные стандарты записи. Максимум 31 символ.
	совет:
		Осмысленные имена в соответствии с их назначением, причем такие, чтобы их было трудно спутать друг с другом. Rороткие имена для локальных переменных, особенно для счетчиков циклов, и более длинные для внешних переменных.




2.2 Типы и размеры данных
	базовые типы:
		char — единичный байт, по сути целое число, которое может интерпритироваться как код символа;
		int — целое, обычно отображающее естественное представление целых в машине (размер зависит от машины!);
		float — число с плавающей точкой одинарной точности (размер зависит от машины!);
		double — число с плавающей точкой двойной точности (размер зависит от машины!).
	совет:
		макрос sizeof
	квалификаторы:
		short\long - применяются только к int и по сути явно задают размер переменной. short - 16 bit, long - 32 bit, long long - 64 bit;
		signed\unsigned - со знаком \ без знака; можно применять к любым целым типам (char и int);
		const - указание того, что значение переменной\массива\параметра не будет изменяться.
	исключение:
		long double число с плавающей точкой повышенной точности.




2.2' Представление чисел
	числа типа long завершается буквой l или L; Беззнаковые числа заканчиваются буквой u или U; Можно использовать больше одного модификатора, например, UL. Числа с плавающей точкой имеют десятичную точку. Окончание f или F указывает на тип float. Если у них нет окончания, считается, что они принадлежат к типу double.
	пример:
		12			число, минимально необходимый тип char
		1234		 - short int
		1234L		 - long int
		123.4		 - double
		123.4f		 - float
		1е-2		 - double

	Целое значение помимо десятичного может иметь восьмеричное или шестнадцатеричное. Если константа начинается с нуля, то она представлена в восьмеричном виде, если с 0х или с 0Х, то — в шестнадцатеричном.
	пример:
		0x0			число 0
		0x9			 - 9
		0xA			 - 10
		0xB			 - 11
		0xF			 - 15
		0x10		 - 16
		0xFFFF		 - 65535




2.2'' Представление символов и строк
	Для машины символ - это просто число. Существуют таблицы кодировок, словари, в которых печатным и не печатным символам сопоставлены числовые коды.
	Одна из распространенных ASCII. Она создавалась для обмена информацией по телетайпу. В набор были включены непечатаемые символы, используемые как команды для управления устройством телетайп. Аналогичные команды применялись и в других докомпьютерных средствах обмена сообщениями (азбука Морзе, семафорная азбука), учитывали специфику устройства.

	таблица ASCII определяет коды для символов:
		десятичных цифр;
		латинского алфавита;
		национального алфавита;
		знаков препинания;
		управляющих символов.

	Код символа
    	'\код'
    	пример
    		'\0'		код 0   конец строки
    		'\3'		код 3   конец текста
    		'\32'		код 32  символ пробела ' '
    		'\48'		код 48  символ '1'
    		'\97'		код 97  символ 'а'

    Символ
    	'символ'
    	Для тех кто плохо воспринимает машинные коды. В языке есть возможность сразу писать нужный символ. При компиляции программы он заменится на число автоматически.
    	пример:
			'0'			символ нуля, не есть 0, обычно 0x30
			'1'			символ единицы, не есть 1, обычно 0x31
			'ф'			символ буквы ф
			' '			символ пробела

	Строка
		Символы, рассмотренные нами ранее, сами по себе мало полезны, но из них составляют строки. Строка - это ноль или более символов, заключенных в двойные кавычки.
		пример:
			"строка"
		На более низком уровне строка представляет собой последовательность символов, в конце которой стоит признак окончания последовательности, обычно это символ '\0'.
		пример:
			'с' 'т' 'р' 'о' 'к' 'а' '\0'

	Управляющие последовательности
	    \a Звонок
	    \b Возврат на шаг
	    \t Горизонтальная табуляция
	    \n Переход на новую строку
	    \v Вертикальная табуляция
	    \r Возврат каретки
	    \f Перевод формата
	    \" Кавычки
	    \' Апостроф
	    \0 Ноль-символ
	    \\ Обратная дробная черта

	Гибрид
		внутри строк можно располагать коды символов
		"hybrid \t\48\493\a"




2.3 Объявления
	Все переменные должны быть объявлены раньше, чем будут использоваться, хотя бы неявно — в контексте. Объявление специфицирует тип и содержит список из одной или нескольких переменных этого типа.
	пример:
		int lower, upper, step;
		char с, line [1000];
	Переменные можно распределять по объявлениям произвольным образом. Например, создав отдельное объявление для каждой переменной. Кконечно, такие объявления занимают больше места, но их удобнее модифицировать, сопровождать и комментировать.
	пример:
		//быстрый способ
			type name1, name2 = .., name3;	//комментарий
		//удобный
			type name1;			//комментарий1
			type name2 = ... ;	//комментарий2
			type name3;			//комментарий3

	В объявлении можно задать начальное значение переменной, инициализировать. А можно и не задавать, в этом случае компилятор присвоит ей значение по умолчанию, в зависимости от класса памяти переменной (auto, static, extern, register - см. 4 главу).
	пример:
		double e = 2.71828182845905;




2.4 Константы
	Константы - это данные, числа, символы, строки, изменение которых не предполагается. Попытка изменения вызывает ошибку компиляции. Бывают неименованные константы и именнованные. Неименнованные константы часто называются "магическими числами", потому что часто непонятно откуда оно взялось.
	пример:
								//вариант 1. неименованная константа
		y = 256;				//запись в переменную неименованной константы
		x = 256;

								//вариант 2. именованная константа
		const int MAX = 256;	//объявление именнованной константы MAX
		y = MAX;				//запись в переменную именнованной константы
		x = MAX;

	Плюсы испозования именованных констант:
		легче читать и поддерживать код;

	Константные выражения - это выражения, оперирующие только с константами. Такие выражения вычисляются во время компиляции, а не во время выполнения, и поэтому их можно использовать в любом месте, где допустимы константы.
	пример:
		const int CLOCK_FREQ   = 1024;				//создание константы
		const int CLOCK_PERIOD = (1/CLOCK_FREQ);	//применение ее в константном выражении
		timeout = 4 * CLOCK_PERIOD;					//установка таймаута в 4 периода

	доп. материал:
		Константы можно создавать с помощью перечисления (enumeration) - в языке Си это список целых констант. Первое имя в списке имеет значение 0 и каждое следующее на 1 больше. Можно прерывать последовательность, самостоятельно задавая значение константы.
		пример:
			enum USB_Port { USB0, USB4 = 4 };		//создание перечисления
			enum USB_Port myusb;					//создание перменной перечисляемого типа
			myusb = USB0;							//присваивание ей значения

			enum Boolean { NO, YES };
			enum Boolean flag;


		Константы можно создавать с помощью дерективы компилятора #define.
		#define A B - говорит компилятору заменять A на B. Это один из самых распространненых способов создания именованных констант и один из самых опасных при неловком обращении.
		пример:
			#define MAXFLOAT 3.40282347e+38F	//создание константы
			foo = MAXFLOAT;						//применение



2.6 Операторы отношения и логические операторы
	Иногда данные нужно сравнивать между собой. Для этого используются операторы отношения.
	Операторы отношения:
		>	больше
		>=	больше либо равно
		<	меньше
		<=	меньше либо равно
		==	равно
		!=	не равно

	Приоритет выполнения операторов
		Все они имеют одинаковый приоритет. Сразу за ними идет приоритет операторов сравнения на равенство: == !=. Операторы отношения имеют более низкий приоритет, чем арифметические, поэтому выражение вроде i < lim-1 будет выполняться так же, как i < (lim-1), т. е. как мы и ожидаем.
	Более интересны логические операторы && и ||. Выражения, между которыми стоят операторы && или ||, вычисляются слева направо. Вычисление прекращается, как только становится известна истинность или ложность результата.
	пример:
		(a == 0) && (b > 10) && (b < 20)
		(a == 0) || (b > 10) || (b < 20)

	Унарный оператор ! преобразует ненулевой операнд в 0, а нуль в 1. Обычно оператор ! используют в конструкциях вида if (!valid) "если не правильно", что эквивалентно if (valid == 0).



2.5 Арифметические операторы
	Бинарными (т. е. с двумя операндами) арифметическими операторами являются +, -, *, /, а также оператор деления по модулю %. Деление целых сопровождается отбрасыванием дробной части, какой бы она ни была. Выражение дает остаток от деления х на y и, следовательно, нуль, если х делится на y нацело.
	пример:
		год является високосным, если он делится на 4, но не делится на 100. Кроме того, год является високосным, если он делится на 400.
		(year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)

	Оператор % к операндам типов float и double не применяется. В какую сторону (в сторону увеличения или уменьшения числа) будет усечена дробная часть при выполнении / и каким будет знак результата операции % с отрицательными операндами, зависит от машины.

	Бинарные операторы + и - имеют одинаковый приоритет, который ниже приоритета операторов *, / и %, который в свою очередь ниже приоритета унарных операторов + и -. Арифметические операции одного приоритетного уровня выполняются слева направо.
	пример:



2.7 Преобразования типов
	Некоторые операторы в зависимости от своих операндов могут вызывать преобразование их значений из 	одного типа в другой. В этом параграфе объясняется, что следует ожидать от таких преобразований.

	Целочисленное повышение.
		Объект типа перечисление, символ, короткое целое, целое в битовом поле — все они со знаком или без могут использоваться в выражении там, где возможно применение целого. Если тип int позволяет "охватить" все значения исходного типа операнда, то операнд приводится к int, в противном случае он приводится к unsigned int. Эта процедура называется целочисленным повышением.


	Арифметические преобразования
		Во многих операциях преобразование типов операндов и определение типа результата осуществляются по одним и тем же правилам. Они состоят в том, что операнды приводятся к некоторому общему типу, который также  является  и  типом  результата.  Эти  правила  называются  обычными  арифметическими преобразованиями и выглядят достаточно громоздко:

		- если один из операндов имеет тип long double, то другой приводится к long double.
		- иначе, если один из операндов имеет тип double, то другой приводится к double.
		- иначе, если один из операндов имеет тип float, то другой приводится к float.
		- иначе для обоих операндов осуществляется  целочисленное повышение; затем, если один из операндов имеет тип unsigned long int, той другой преобразуется в unsigned long int.
		- иначе, если один из операндов принадлежит типу long int, а другой — unsigned int, то результат зависит от того, покрывает ли long int все значения unsigned int, и если это так, то unsigned int  приводится  к long int; если нет, то оба операнда преобразуются в unsigned long int.
		- иначе, если один из операндов имеет тип long int, то другой приводится к long int.
		- иначе, если один из операндов — unsigned int, то другой приводится к unsigned int.
		- иначе оба операнда имеют тип int.

	Целые и числа с плавающей точкой.
		При преобразовании из типа с плавающей точкой в целочисленный дробная часть значения отбрасывается; если полученное при этом значение нельзя представить в заданном целочисленном типе, то результат не определен. В частности, не определен результат преобразования отрицательных значений с плавающей точкой в беззнаковые целые. Если значение преобразуется из целого в величину с плавающей точкой и она находится в допустимом диапазоне, но представляется в новом типе неточно, то результатом будет одно из двух значений нового типа,  ближайших  к  исходному.  Если  результат  выходит  за  границы  диапазона  допустимых  значений, поведение программы не определено.




2.8 Операторы инкремента и декремента
	В Си есть два необычных оператора, предназначенных для увеличения и уменьшения переменных. Оператор инкремента ++ добавляет 1 к своему операнду, а оператор декремента -- вычитает 1.
	пример:
		//a = a + 1;	//полная версия
		a++;			//сокращенная, постфиксная

	Необычность операторов ++ и -- в том, что их можно использовать и как префиксные (помещая перед переменной: ++n), и как постфиксные (помещая после переменной: n++) операторы. В обоих случаях значение n увеличивается на 1, но выражение ++n увеличивает n до того, как его значение будет использовано, а n++ — после того
	пример:
		//x = a;		//сначала присвоили
		//a = a + 1;	//потом увеличили
		x = a++;		//эквивалентная постфиксная запись

		//a = a + 1;	//сначала увеличили
		//x = a;		//потом присвоили
		x = ++a;		//эквивалентная префиксная запись

		//a[n]= 0;		//запись нуля в элемент массива под номером n
		//n++;			//изменение номера элемента на n+1
		a[n++] = 0;		//эквивалентная постфиксная запись



2.9 Побитовые операторы
	В  Си  имеются  шесть  операторов  для  манипулирования  с  битами.  Их  можно  применять  только  к целочисленным операндам, т. е. к операндам типов char, short, int и long, знаковым и беззнаковым.
		&  — побитовое И.
		|  — побитовое ИЛИ.
		^  — побитовое исключающее ИЛИ.
		<<  — сдвиг влево.
		>>  — сдвиг вправо.
		~  — побитовое отрицание (унарный).

	Оператор & (побитовое И) часто используется для обнуления некоторой группы разрядов.
	пример:
		n = n & 0x3;     обнуляет в n все разряды, кроме младших двух.

	Оператор | (побитовое ИЛИ) применяют для установки разрядов.
	пример:
		х = х | SET_ON; устанавливает единицы в тех разрядах x, которым соответствуют единицы в SET_ON.

	Оператор ^ (побитовое исключающее ИЛИ) в каждом разряде установит 1, если соответствующие разряды операндов имеют различные значения, и 0, когда они совпадают.

	Поразрядные операторы & и | следует отличать от логических операторов && и ||, которые при вычислении слева направо дают значение истинности. Например, если x равно 1, а y равно 2, то x & y даст нуль, а x && у единицу.

	Операторы << и >> сдвигают влево или вправо свой левый операнд на число битовых позиций, задаваемое правым операндом, который должен быть неотрицательным.
	пример:
		х << n сдвигает значение х влево на n позиций, заполняя освобождающиеся биты нулями (при условии что x не отрицательно), что эквивалентно умножению х  на 2^n.

	Унарный оператор ~ поразрядно инвертирует биты.
	пример:
		char х = ~0xF0

	пример:
		подсчет в переменной бит равных "1"
		до тех пор пока (x != 0)
		x = x >> 1;
		если (x & 01)
		то число бит +1
		(где это нужно? пример с двигателями)



2.10 Операторы и выражения присваивания
	Выражение (i = i + 2) в котором стоящая слева переменная повторяется и справа, можно написать в сжатом виде (i += 2). Большинству бинарных операторов (аналогичных + и имеющих левый и правый операнды) соответствуют операторы присваивания "ор=", где ор — один из операторов (+  *  /  %  <<  >>  &  ^  | ) 	(a = a op b) эквивалентно (a op= b). Это часто облегчает чтение кода программы, но бывает и наоборот. так что не стоит злоупотреблять.
	пример:
		yyval[yypv[p3+p4] + yypv[p1+p2]] += 2;
		читателю при не потребуется старательно сравнивать два длинных выражения.



2.11 Условные выражения
	иногда выражения вида
		if (a)	b;
		else 	c;
	удобно записать сокращенно
		a ? b : c
	пример:
		print ((i%10 == 9 || i == n-1) ? 'n' : ' ');



2.12 Приоритет и очередность вычислений
	Приоритеты.
		Существует таблица приоритетов и очередностей вычислений всех операторов, включая и те, которые мы еще не рассматривали. Но не будем на ней подробно останавливаться.
	Очередность.
		Си подобно многим языкам не фиксирует очередность вычисления операндов оператора (за исключением & &, ||, ?: и ,).
		пример:
			х = f() + g();
			f  может быть вычислена раньше g  или наоборот. Из этого следует, что  если одна из функций изменяет значение переменной, от которой зависит другая функция, то помещаемый в x результат может зависеть от очередности  вычислений.  Чтобы  обеспечить  нужную  последовательность  вычислений,  промежуточные результаты можно запоминать во временных переменных.

		Кроме того обращения к функциям, вложенные присвоения, инкрементные и декрементные операторы дают "побочный эффект",  проявляющийся  в  том,  что  при  вычислении  выражения  значения  некоторых  переменных изменяются. В любом выражении с побочным эффектом может быть скрыта трудно просматриваемая зависимость  результата  выражения  от  очередности  изменения  значений  переменных,  входящих  в выражение.
		пример:
			foo(++n, power(2,n));
			Очередность вычисления аргументов функции также не определена, поэтому на разных компиляторах 	может давать несовпадающие результаты. Результат вызова функции  зависит от того, когда компилятор сгенерирует команды увеличения n  —  до или после обращения к power. Чтобы обезопасить себя достаточно написать
			++n;
			foo (n, power(2,n));
		пример:
			a[i] = i++;
			возникает вопрос: массив a индексируется старым или измененным значением i?

	Стандарт сознательно устроен так, что большинство подобных вопросов оставлено на усмотрение компиляторов, так как лучший порядок  вычислений  определяется  архитектурой  машины.  Стандартом  только  гарантируется,  что  все побочные эффекты при вычислении аргументов проявятся перед входом в функцию. Правда, нам это уже не поможет.
	Так что: какой бы язык вы ни использовали, пишите программы, не зависящие от очередности вычислений.



















