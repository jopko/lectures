# введение

в этой лекции мы поговорим про

+  оператор `=`
+  функции `main()`, `printf()`
+  создадим простую программу
+  объявим переменную, присвоим ей значение и выведем на экран
+  символ новой строки
+  комментарии в вашей программе
+ _создадим программу с больше чем одной функцией_
+ _поиск ошибки._
+  отладку


## простой пример
В этой главе мы напишем простую программу и опишем что она делает и одновременно поговорим про основные особенности Си. Попробуйте предположить что делает эта программа и какой будет результат ее работы

листинг1.

    #include <stdio.h>                          // подключение библиотеки
    int main(void)                              // простая программа
    {
        int num;                                // определяем переменную
        num = 1;                                // присваиваем значение
        printf("I am a simple ");               // вызов функции printf()
        printf("program.\n"); 
        printf("My favorite number is %d.\n",num);
        return 0;
    }

если вы думаете что эта программа что-то печатает, то вы правы. но напечатаются не все символы. чтобы проверить это самому запустите ваш любимый редактор, напишите в нем эту программу, сохраните файл с расширением *.c, откомпилируйте и запустите. если все сделано правильно то вы получите:

    I am a simple program.
    My favorite number is 1.


# разбор листинга 1

    #include <stdio.h>

включение другого файла, это строка говорит компилятору включить информацию найденную в файле `stdio.h`, которая является стандартной частью всех Си компиляторов. этот файл обеспечивает подержку ввода\вывода информации.

    int main(void)

имя функции. Си программы состоят из одной или нескольких функций, базовых модулей Си программ. Наш пример состоит из одной функции, называемой `main`. Круглые скобки выдают в `main()` имя функции. `int` говорит, что функция возвращает целочисленное значение. а `void` говорит о том, что функция не имеет каких либо входных аргументов. но про это позже.

    // a simple program

комментарий. символ `//` окаймляет комментарии, пометки которые помогают пояснить программу. Они предназначены только для читателя, и игнорируются компилятором.

    {

начало тела функции, открытая скобка отмечает начало тела функции. конец тела функции определяется фигурной скобкой `}`

    int num;

обявление переменной, эта строка говорит о том, что вы будите использовать переменную num, и что num будет целочисленного типа `int`.

    num = 1;

присваивание значения, высказывание `num = 1` присваивает переменной `num` значение 1

    printf("I am a simple ");

первый вызов функции `printf()` выведет на экран `I am a simple`. функция `printf()` является частью стандартной библиотеки Си. 

    printf("computer.\n");

следующий вызов функции `printf()` напечатает `computer.` а символ `\n` говорит компьютеру перевести каретку в начало новой строки.


    printf("My favorite number is %d.\n", num);

последний вызов `printf()` выведет на экран значение переменной `num` в составе строке `My favorite number is`. Символ `%d` информирует в каком виде выводить num. В данном случае это десятичное число.

    return 0;

возвращаемое значение, функции в Си могут возвращать значения агентам, их вызвавшим.

    }

Программа заканчивается закрывающей фигурной скобкой



# подробный разбор листинга 1

## `#include` Directives and Header Files

    #include <stdio.h> 

это строка которой начинается файл. эффект от нее точно такой же, если вы просто скопируете на ее место содержимое файла `stdio.h`. включение файлов представляет собой удобный способ обмена информацией, и довольно часто встречается во многих программах.

запись `#include` является одной из деректив препроцессора. В целом, Си компиляторы перед тем как запустить компиляцию, проводят некоторую предварительную обработку исходного кода.

файл stdio.h является частью всех пакетов компиляторов. он содержит информацию о функциях ввода и вывода, таких как printf(). название файла расшифровывается как `standard input/output` = `std io`. Обычно такие файлы, сборники информации, называются файлами заголовкой `header file`, *.h

По большей части заголовочные файлы содержат информацию используемую компилятором для сборки программы. Например, в них может содержатся константы или названия функция и правила их вызова. Но реальный исполняемый код функций находится в библиотечных файлах, не в заголовочных файлах. Линковщик заботится о нахождении нужной библиотеки. Если коротко, заголовочные файлы помогают корректно объединить ващи программы.

Стандарт `ISO/ANSI C` описывает какие заголовочные нужно подключать, чтобы получить доступ к тем или иным стандартным библиотечным функциям.



### почему ввод\вывод не вмонтированны в Си

Возможно, вы задаетесь вопросом, почему базовый инструмент ввода\вывода не вмонтированн в язык. Один из ответов, потому что не все программы его используют. Это часть философии Cи, для того чтобы избежать ненужного кода. Этот принцип хозяйственного использования ресурсов делает Cи популярным для встроенных систем, например, написание кода для чипа, который управляет автомобильной топливной системы.


## функция main()

    int main(void)

Эта строка из программы провозглашает функцию по имени main. Правда, main, довольно простое имя, но это единственный доступный выбор. Программа на Си (с некоторыми исключениями мы не будем беспокоиться о) всегда начинается выполнение функции, вызываемой main(). Вы свободны в выборе названия для других функций, которые вы используете, но main() должен быть там, чтобы начать. Что можно сказать о скобках? Они определяют main() в качестве функции. Вы узнаете больше о функциях в ближайшее время. В настоящее время, только помните, что функции являются основными модулями программы C.


int является типом данных, возвращаемых функцией main(). это означает, что main() возвращать целочисленное значение. Но возвращает куда? В операционную систему, например. Из под которой запускается программа.

В скобках после имени функции, как правило, содержится информация передаваемая функции. В этом простом примере, ничего не передается, так что скобки содержат слово void - пустота. 

Если вы просматриваете древний код Cи, вы часто будете видеть программы, начинающиеся с:

    main()

Стандарт C90 неохотно терпел эту форму, но стандарт C99 нет. Таким образом, даже если ваш текущий компилятор позволяет это сделать, не делайте.
Ниже еще одна форма которую вы можете встретить:
 
    void main()

Некоторые компиляторы позволяют это, но ни один из стандартов не допускает ее как корректную. Таким образом, компиляторы не должны принимать эту форму, и некоторые так и делают. Опять же, придерживаться стандартной формы, и вы не столкнетесь с проблемами, если вы переместите программу из одного компилятора на другой.




## Comments

    /* a simple program */


части программы заключены в `/ *` `* /` символов комментариев. Использование комментарии облегчает понимание программы. Одна хорошая особенность комментариев в Си состоит в том, что они могут быть размещены в любом месте, даже на той же линии, что и материал, который они объясняют. Большие комментарии могут быть размещены на отдельной строке или даже на нескольких. Все между открытием `/*` и закрытия `* / 'игнорируется компилятором. Ниже приведены некоторые правильные и неправильные способы комментирования:

    /* This is a C comment. */ 

    /* This comment is spread over 
       two lines. */ 

    /* 
    You can do this, too. 
    */

    /* But this is invalid because there is no end marker.

C99 добавляет второй стиль комментариев, популярный в C++ и Java. Новый стиль использует символы `//`, чтобы создавать комментарии, которые ограничены в одной строкой:

    // Here is a comment confined to one line. 
    int rigue;      // Such comments can go here, too.

Потому что конец строки знаменует собой конец комментария, этот стиль нуждается в маркере начала комментария. Новая форма решает потенциальную проблему со старой формой. Предположим, у вас есть следующий код:

    /* 
    I hope this works. 
    */ 
    x = 100; 
    y = 200; 
    
    /* Now for something else. */ 

Далее, предположим, что вы решите удалить четвертую строку и случайно удалит третью строку `*/`. Код становится

    /* 
    I hope this works. 
    y = 200; 
    /* Now for something else. */



Теперь компилятор связывает `/*` в первой строке с `*/` в четвертой строке, делая все четыре строки одним большим комментарием, в том числе строки, которые должны были быть частью кода. Форма `//` не распространяется на более чем одной линии, и не может привести к этой проблеме "исчезновения код". Некоторые компиляторы могут не поддерживать эту функцию C99; другие могут потребовать изменения настроек компилятора.

Использует оба вида комментариев.




## Скобочки, тела, блоки

    { 
    ... 
    }

В листинге, фигурные скобки окаймляют функцию main(). В общем, все функции Cи использовать фигурные скобки, чтобы отметить начало, а также конец тела функции. Их присутствие является обязательным, поэтому не оставляйте их. Только фигурные скобки (`{}`) используются для этой цели, а не круглые скобки (`()`) или квадратные (`[]`). Фигурные скобки могут быть также использованы для объединения каких то частей программы в блоки. Если вы знакомы с Паскалем, Ада, Модула-2, или Алгол, то вам знакомы эти фигурные скобки и как их используют в начале и конце.



## Объявления 

    int num; 

Эта строка называется оператором объявления. Оператором объявления является важной особенностью языка. В этом примере он говорит нам сразу о двух вещах. Во-первых, где-то есть переменная с именем `num`. Во-вторых, слово `int` сообщает нам, что она целочисленная. Компилятор использует эту информацию для организации подходящего места для хранения в памяти переменной `num`. Точка с запятой в конце строки определяет строку программы как оператор или команду. Точка с запятой является частью выражения, а не просто разделителем между выражения, как в Pascal.

ключевое слово `int`  служит для идентификации одного из основных типов данных. Ключевые слова являются зарезервированными и правила их использования регламентированны. Например, вы не можете использовать `int` в качестве имени функции или переменной.

Слово `num` в этом примере является идентификатором, то есть именем присвоенным переменной, функции или какому-либо другому объектому. Так объявление соединяет уникальный идентификатор с определенным местом в памяти компьютера, и также устанавливает тип информации, или тип данных, который будет находиться в этом месте.

В C, все переменные должны быть объявлены до их использования. Это означает, что вы должны предоставить списки всех переменных, которые вы используете в программе, и вы должны указать тип данных каждой переменной. Объявление переменных считается хорошей техникой программирования и в С является обязательным.




Traditionally, C has required that variables be declared at the beginning of a block with no other kind of statement allowed to come before any of the declarations. That is, the body of main() might look like the following:

Традиционно, C требует, чтобы переменные были объявлены в начале блока, раньше всех других объявлений или выражения. То есть, тело `main()` может выглядеть следующим образом:

    int main()          // traditional rules 
    { 
        int doors; 
        int dogs; 
        doors = 5; 
        dogs = 3; 
        ...
    }


C99, following the practice of C++, now lets you place declarations about anywhere in a block. However, you still must declare a variable before its first use. So if your compiler supports this feature, your code can look like the following:

Стандарт C99, в соответствии с практикой C++, позволяет размещать объявления в любом месте блока. Тем не менее, вы все равно должны объявить переменную перед первым использованием. Так что, если ваш компилятор поддерживает эту функцию, ваш код может выглядеть следующим образом:


    int main()                  // C99 rules 
    { 
        ...
        int doors; 
        doors = 5;
        ...
        int dogs; 
        dogs = 3;
        ...
    }

Для большей совместимости со старыми системами, рекомендуется придерживаться первоначального соглашения.


На данный момент у вас, вероятно, есть три вопроса.

+ какие еще бывают типы данных?
+ какой выбор у вас есть при выборе имени?
+ почему вы вообще должны объявлять переменные?




## Типы данных

С имеет дело с несколькими видами (или типами) данных: целые числа, символы, с плавающей точкой, например. Объявление типа переменной позволяет машине хранить, извлекать и интерпретировать данные должным образом.




## Выбор имени

Вы должны использовать осмысленные имена для переменных (например, если ваша программа подсчитывает овец, то лучше использовать `sheep_count` вместо `x3`). Если имени не хватает, используйте комментарии, чтобы объяснить то, что переменная представляет. Документирование программы таким образом, является одним из основных методов хорошего программирования.

Количество символов, которые вы можете использовать варьируется в зависимости от реализации. Стандарт C99 поддерживает до 63 символов, для внешних идентификаторов, и только 31 символ для внешних имен. Это существенное увеличение по сравнению с требованием C90 31 символов и шести символов, соответственно. Старые компиляторы C часто останавливался на восьми символах максимум. На самом деле, вы можете использовать более, чем максимальное количество символов, но компилятор не будет обращать внимание на лишние символы.

Для идентификаторов в вашем распоряжении строчные буквы, прописные буквы, цифры и подчеркивания (`_`). Первый символ должен быть буквой или подчеркивания. Ниже приведены некоторые примеры:


    Valid Names     Invalid Names
    -----------------------------
    wiggles         $Z]** 
    cat2            2cat 
    Hot_Tub         Hot-Tub 
    taxRate         tax rate 
    _kcab           don't

Операционные системы и библиотеки C часто используют идентификаторы с одним или двумя начальных символов подчеркивания, так что лучше, избегать в своих программах подчеркивания в начале имени. 

в С имена чувствительны к регистру, то есть заглавную букву считается отличным от соответствующего строчной буквы. Таким образом, `stars` отличается от `Stars` и `STARS`.



## Четыре причины для объявления переменных

Некоторые старые языки, такие как первоначальные формы `FORTRAN` и `BASIC`, позволяют использовать переменные без объявления их. Так почему вы не можете принять это легко собирается подхода в C? Вот некоторые причины:

+ размещение переменных в одном месте, делает код легче для восприятия, и понимания, что именно программа делает. Это особенно верно, если вы даете переменным осмысленные имена (например, `taxrate` вместо `г`). Если имени не достаточно, используйте комментарии, чтобы объяснить, назначение переменной. Документирование программы таким образом, является одним из основных методов хорошего программирования.

+ Думая о том, какие переменные объявлять, позволяет вам сделать некоторое планирование, прежде чем погрузиться в написании программы. Какую информацию нужно, чтобы начать программу? Что именно я хочу чтобы программа сделала? Какой способ представления данных выбрать?


+ Объявление переменных помогает предотвратить многие хитрые и трудно находимые ошибки.

    For example, suppose that in some language that lacks declarations, you made the statement 

    Например, предположим, что в каком-то языке, вы сделали заявление
        
        RADIUS1 = 20.4;

    и что в другом месте программы вы опечатались

        CIRCUM = 6.28 * RADIUSl;

    Вы невольно заменить цифру 1 с буквой л. Этот другой язык создаст новую переменную называемый `RADIUSl` и присвоет ей произвольное значение (возможно, ноль, возможно, мусор). `CIRCUM` будет присвоено неверное значение, и вам, возможно, придется потратить чертовски много времени, пытаясь выяснить, почему это происходит. Это не может произойти в С (если вы не были настолько глупы, чтобы объявить два таких подобных имен переменных), потому что компилятор будет жаловаться, когда необъявленная `RADIUSl` покажется в коде.


+ Если предыдущие причины не убедили вас, то в конце концов ваша программа просто не будет компилироваться, если вы не объявите переменные.




## Присваивание значений

    num = 1;

Следующая строчка программы выполняет операцию присваивания, это одна из основных операций в C. В этом конкретном примере означает "присвоить значение 1 к переменной `num`. Ранее строчка `int num;` уже выделила пространство в памяти компьютера для переменной `num`, а строчка присваивания сохраняет новое значение в этом месте. Вы можете назначить `num` другое значение позже, если вы хотите; поэтому `num` называют переменную. Обратите внимание, что оператор присваивания присваивает значение с правой стороны на левую сторону.






## функция printf()

    printf("I am a simple "); 
    printf("computer.\n"); 
    printf("My favorite number is %d.\n", num);

Все эти строки используют стандартную функцию C под названием printf(). Скобки означают, что printf является именем функции. Материал, заключенный в скобках это информация, передаваемая от функции main() к функции printf(). Например, первая строчка передает фразу `I am a simple` к функции printf(). Такая информация называется аргументом или, более полно, фактический аргумент функции. Что функция printf() делать с этим аргументом? Отправляет на печать все, что лежит между двойными кавычками.

Первая строка printf() пример того, как вызывать функцию в С. Вам нужно ввести только имя функции, размещая нужные аргументы в круглых скобках. Когда программа достигнет этой строки, управление перейдет к вызываемой функции. Когда функция закончила все, что она возвращается управление, в нашем случае в функцию main(). 

Что об этом в следующем строки с printf()? Он имеет символы `\n` включены в кавычки, и он не напечатался! Что происходит? Символ `\n` означает начало новой строки. `\n` комбинация (набирается в виде двух символов) представляет собой один символ, называемый символ новой строки. Для printf(), это означает, "начать новую строку в дальнем левом краю." Другими словами, печать символ новой строки выполняет ту же функцию, что и нажатие клавиши Enter типичного клавиатуры. Символ новой строки, однако, влияет на способ отображения выходной программы.

    My favorite number is 1.

    PRINT "My favorite number is "; num; "." 

`%` предупреждает программу, что в этом месте нужно напечатать переменную, а `d` рассказывает в каком виде вывести ее на печать. В виде десятичной дроби (база 10) число. в виде шестнадцатеричного числа (основание 16)  или числа с точкой. Действительно, `F` в `printf()` является напоминанием о том, что это функция форматирования печати.





## заявление возвращения

    return 0;

Этот оператор возврата является последним в программе оператором. `int` в `int main(void)` означает, что функция `main()` должна возвращать целое число.Стандарт C требует, чтобы функция `main()` вела себя именно так. C Функции, которые возвращают значения, делают это с помощью оператора возврата, который состоит из ключевого слова `return` и возвращаемого значения, за которым следует точка с запятой.

Если вы опустите оператор возврата для `main()`, большинство компиляторов пожурить за бездействие, но все еще будет скомпилировать программу. На данный момент, вы можете рассматривать `return` в `main()`, как что-то необходимое для логической последовательности, но это имеет практическое применение с некоторыми операционными системами, в том числе `DOS` и `Unix`. Функции возвращают код завершения операции. Например, если функция вернула -1, то все прошло гладко.



## Tips on Making Your Programs Readable 

Создание ваших программы более читабельными это хорошая практика программирования. Программы которые легко читать, легче понять, починить или изменить. Создание читабельных программ будет полезно и вам, так как поможет прояснить вашу собственную концепцию программы.

+ Вы уже видели два метода для улучшения читабельности: выбор значимых имен переменных и использование комментариев. Следует отметить, что эти два метода дополняют друг друга. Если вы даете переменную с говорящем именем, вы не нуждаетесь в комментариях о том, что эта переменная представляет собой (переменная с именем `video_day_4` говорит о том, что это видео 4 дня).

+ Другой способ заключается в использовании пустых строк, чтобы отделить один концептуальный раздел функции от другого. Стандарт С не требует пустых строк (и не запрещает), но это может улучшить читаемость.

+ Четвертый способ заключается в использовании одной строки для каждого оператора. Опять же, это соглашение для повышение читаемости, а не требование стандарта C. C имеет формат в свободной форме. Вы можете разместить несколько операторов в одной строке или распространять одно заявление по несколько. Можете хоть всю программу написать в одну строчку, но это не улучшит ее читаемость.

        int main (void) {int four; four = 4; printf("%d\n", four); return 0;}




## Введение в отладку Introducing Debugging 

Теперь, вы можете написать простую программу на С и допустить в ней простые ошибки. Ошибки программы называют багами - жучками, а поиск и устранение ошибок называется отладкой.

Пример программы с некоторыми ошибками. Сколько вы можете обнаружить?

    /*  nogood.c -- a program with errors */ 
    #include <stdio.h> 
    int main(void) 
    ( 
        int n, int n2, int n3; 
     
        /* this program has several errors 
        n = 5; 
        n2 = n * n; 
        n3 = n2 * n2; 
        printf("n = %d, n squared = %d, n cubed = %d\n", n, n2, n3) 
     
        return 0; 
    )


### Синтаксические ошибки

Листинг содержит несколько синтаксических ошибок. Вы допускаете ошибку синтаксиса, когда вы не следуете правилам языка Си. Это похоже на грамматические ошибки в обычном языке. Синтаксические ошибки C использовать действительные символы с в неположенных местах.

Так какие синтаксические ошибки содержаться в листинге?

+ Во-первых, он использует обычные скобки вместо фигурных, чтобы отметить тело функции (т.е. он использует правильный символ, но не в том месте).

+ Во-вторых, объявление переменных должно было быть таким

        int n, n2, n3;

    ну или таким
 
        int n; 
        int n2; 
        int n3;


Next, the example omits the `*/` symbol pair necessary to complete a comment. (Alternatively, you  could  replace `/*` with  the  new `//` form.) Finally,  it  omits  the  mandatory  semicolon  that should terminate the printf() statement. 

+ пропущен символ `*/` необходимый для завершения комментария (В качестве альтернативы, вы можете заменить `/*` на `//`)
+ Наконец, пропущена обязательная запятая после printf().






How do you detect syntax errors? First, before compiling, you can look through the source code and  see  whether  you  spot  anything  obvious.  Second,  you  can  examine  errors  found  by  the compiler because part of its job is to detect syntax errors. When you compile this program, the compiler reports back any errors it finds, identifying the nature and location of each error. 

Как вы обнаруживать синтаксические ошибки? Во-первых, перед компиляцией, вы можете просмотреть исходный код и убедиться в том вы заметили что-нибудь очевидное. Во-вторых, вы можете изучить ошибки, найденные компилятором, так как часть его работы является выявление синтаксических ошибок. При компиляции программы, компилятора сообщает о всех ошибках которые находит, рассказывает о их характере и местоположении.




However,  the  compiler  can  get  confused.  A  true  syntax  error  in  one  location  might  cause  the compiler to mistakenly think it has found other errors. For instance, because the example does not declare n2 and n3 correctly, the compiler might think it has found further errors whenever those  variables  are used. In  fact,  rather than trying to  correct  all the  reported  errors  at  once, you should correct just the first one or two and then recompile; some of the other errors may go away. Continue in this way until the program works. Another common compiler trick is reporting the error a line late. For instance, the compiler may not deduce that a semicolon is missing until it  tries to  compile the next line.  So if  the  compiler  complains  of  a missing  semicolon  on  a  line that has one, check the line before.

Тем не менее, компилятор может запутаться. Правда синтаксическая ошибка в одном месте может привести к компилятору ошибочно думают, он нашел другие ошибки. Например, потому что пример не объявить N2 и N3 правильно, компилятор может подумать, она нашла дальнейших ошибок, когда используются эти переменные. В самом деле, вместо того, чтобы исправить все обнаруженные ошибки сразу, вы должны исправить только одну или две, а затем перекомпилировать; некоторые другие ошибки может уйти. Продолжайте таким образом, пока программа не работает. Еще одна распространенная компилятор трюк, сообщающий об ошибке линия поздно. Например, компилятор может не сделать вывод, что с запятой отсутствует до тех пор, пока пытается составить следующую строку. Так что, если компилятор жалуется на точку с запятой в строке, которая имеет один, проверить линию раньше.




### Semantic Errors 

Semantic  errors  are  errors  in  meaning.  For  example,  consider  the  following sentence: Furry inflation thinks greenly. The syntax is fine because adjectives, nouns, verbs, and adverbs are in the  right  places,  but  the  sentence  doesn't  mean  anything.  In  C,  you  commit  a  semantic  error when  you  follow  the  rules  of  C  correctly  but  to  an  incorrect  end.  The  example  has  one  such error: 

Семантические ошибки это ошибки по смыслу. Например, рассмотрим следующее предложение: Furry инфляция считает Greenly.Синтаксис это прекрасно, потому прилагательные, существительные, глаголы, и наречия в нужных местах, но предложение ничего не значит. В C, вы фиксируете смысловую ошибку при соблюдении правил С правильно, но к неправильному конца.Пример имеет одну такую ошибку:



n3 = n2 * n2;



Here, `n3` is supposed to represent the cube of `n`, but the code sets it up to be the fourth power of `n`. 

Здесь `n3` должен представлять куб` N`, но код устанавливает его, чтобы быть четвертой властью в `N`.



The compiler does not detect semantic errors, because they don't violate C rules. The compiler has no way of divining your true intentions. That leaves it to you to find these kinds of errors. One  way  is  to  compare  what  a  program  does  to  what  you  expected  it  to  do.  For  instance, suppose you fix the syntax errors in the example so that it now reads as shown in Listing 2.5.

Компилятор не обнаруживает семантических ошибок, потому что они не нарушают правила C.Компилятор не имеет возможности угадывать ваши истинные намерения. Это оставляет его для вас, чтобы найти эти виды ошибок. Одним из способов является сравнить то, что программа делает то, что вы ожидали это делать. Например, предположим, что вы исправить синтаксические ошибки в примере, так что теперь читает, как показано в листинге 2.5.






Listing 2.5. The stillbad.c Program 
 
    /* stillbad.c -- a program with its syntax errors fixed */ 
    #include <stdio.h> 
    int main(void) 
    { 
        int n, n2, n3; 
     
        /* this program has a semantic error */ 
        n = 5; 
        n2 = n * n; 
        n3 = n2 * n2; 
        printf("n = %d, n squared = %d, n cubed = %d\n", n, n2, n3); 
     
        return 0; 
    }


Its output is 
    
    n = 5, n squared = 25, n cubed = 625 

If you are cube-wise, you'll notice that 625 is the wrong value. The next stage is to track down how  you  wound  up  with  this  answer.  For  this  example,  you  probably  can  spot  the  error  by inspection. In general, however, you need to take a more systematic approach. One method is to  pretend  you  are  the  computer  and  to  follow  the  program  steps  one  by  one.  Let's  try  that method now.

Если вы куба мудрый, вы заметите, что 625 неправильное значение.Следующий этап, чтобы выследить, как вы завелся с этим ответом. Для этого, например, вы, вероятно, можете определить ошибку осмотром. В целом, однако, вы должны принять более систематический подход. Одним из способов является вид, что вы компьютер и следовать программе пункты один за другим. Давайте попробуем этот метод в настоящее время.






The  body  of  the  program  starts  by  declaring  three  variables: n, n2,  and n3.  You  can  simulate this  situation  by  drawing  three  boxes  and  labeling  them  with  the  variable  names  (see Figure 2.6).  Next,  the  program  assigns 5 to n.  Simulate  that  by  writing 5 into  the n box.  Next,  the program multiplies n by n and assigns the result to n2, so look in the n box, see that the value is 5, multiply 5 by 5 to get 25, and place 25 in box n2. To duplicate the next C statement (n3 = n2 * n2;), look in n2 and find 25. You multiply 25 by 25, get 625, and place it in n3. Aha! You are squaring n2 instead of multiplying it by n.

Тело программы начинается с объявления трех переменных: N, N2 и N3. Вы можете моделировать эту ситуацию, опираясь три коробки и маркировка их имена переменных (рис 2,6). Далее программа присваивает 5 п. Имитация, что, написав 5 в N BOX. Далее, программа умножает п на п и присваивает результат п2, так что смотрите в N BOX, видим, что значение 5, умножить 5 на 5, чтобы получить 25, и поместите 25 в коробке N2. Чтобы скопировать следующую инструкцию C (n3 = n2 * n2;), посмотрите в N2 и найти 25. умножить 25 на 25, получаем 625, и поместите его в N3. Ага! Вы возведения N2 вместо умножения его на п.







Figure 2.6. Tracing a program.
    ...

Well, perhaps this procedure is overkill for this example, but going through a program step-by-step in this fashion is often the best way to see what's happening. 

Ну, может быть, эта процедура является излишеством для этого примера, но переживает программе шаг за шагом в этом модном часто лучший способ увидеть, что происходит.






### Program State 

By tracing the program step-by-step manually, keeping track of each variable, you monitor the program state. The program state is simply the set of values of all the variables at a given point in program execution. It is a snapshot of the current state of computation. 

Прослеживая шаг за шагом, программа вручную, отслеживание каждой переменной, отслеживать состояние программы.Государственная программа просто набор значений всех переменных в данной точке при выполнении программы. Это снимок текущего состояния вычислений.





We  just  discussed  one  method  of tracing  the  state:  executing  the  program  step-by-step yourself.  In  a  program  that makes,  say, 10,000 iterations,  you might not  feel up to that  task. Still, you  can  go  through  a  few  iterations  to  see  whether  your  program  does  what  you intend. However, there is always the possibility that you will execute the steps as you intended them to be executed instead of as you actually wrote them, so try to be faithful to the actual code. 

Мы только что обсуждали один метод отслеживания состояния: выполнение программы шаг за шагом самостоятельно. В программе, которая делает, скажем, 10 000 итераций, вы не могли бы чувствовать себя до этой задачи. Тем не менее, вы можете пройти через несколько итераций, чтобы увидеть, делает ли ваша программа, что вы намерены. Тем не менее, всегда есть вероятность того, что вы будете выполнять шаги, как вы хотели, чтобы они были выполнены, а не как вы на самом деле написал их, так что постарайтесь быть верным фактическим кодом.





Another  approach  to  locating  semantic  problems  is  to  sprinkle  extra printf()  statements throughout to monitor the values of selected variables at key points in the program. Seeing how the values change can illuminate what's happening. After you have the program working to your satisfaction, you can remove the extra statements and recompile. 

Другой подход к локализации семантических проблем является посыпать дополнительную Е () отчетности во всем, чтобы контролировать значения выбранных переменных в ключевых точках программы. Видя, как изменяются значения может осветить то, что происходит. После того как вы программу, работающую к вашему удовлетворению, вы можете удалить лишние заявления и перекомпилировать.





A third method for examining the program states is to use a debugger. A debugger is a program that enables you to run another program step-by-step and examine the value of that program's variables.  Debuggers  come  in  various  levels  of  ease  of  use  and  sophistication.  The  more advanced debuggers show which line of source code is being executed. This is particularly handy for programs with alternative paths of execution because it is easy to see which particular paths are being followed. If your compiler comes with a debugger, take time now to learn how to use it. Try it with Listing 2.4, for example.

Третий способ для изучения В программе отмечается, является использование отладчика.Отладчик программа, которая позволяет запускать другую программу шаг за шагом, и проверить значение переменных, которые программы. Отладка прийти в различных уровней удобства использования и изысканности. Более продвинутые отладчики показать, какая строка исходного кода выполняется. Это особенно удобно для программ с альтернативных путей исполнения, потому что это легко увидеть, какие следят особые пути. Если ваш компилятор поставляется с отладчик, потребуется время, сейчас, чтобы узнать, как его использовать. Попробуйте его с листинге 2.4, например.