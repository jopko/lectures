# # 4. Указатели

Содержание

1. Указатели и адреса
2. Указатели и аргументы функций
3. Адресная арифметика
4. Указатели и массивы
Доп материал

 
**Указатель** — это переменная, содержащая адрес переменной. Указатели широко применяются в Си — отчасти потому, что в некоторых случаях без них просто не обойтись, а отчасти потому, что программы с ними обычно короче и эффективнее.
Наряду с `goto`, указатели когда-то были объявлены лучшим средством для написания малопонятных программ.


## ## Указатели и адреса 

Рассмотрим упрощенную схему организации памяти. Память типичной машины представляет собой массив последовательно пронумерованных или проадресованных ячеек, с которыми можно работать по отдельности или связными кусками.

A) Унарный оператор `&` выдает адрес объекта
```C
	р = &с;
```
переменной p присваивается адрес ячейки c (говорят, что `р` указывает на `с`). Оператор `&` применяется только к объектам, расположенным в памяти: к переменным и элементам массивов. Его операндом не может быть ни выражение, ни константа, ни регистровая переменная.

B) Унарный оператор `*` есть оператор косвенного доступа. Примененный к указателю, он выдает объект, на который данный указатель указывает.

пример:
```C
	int х = 1, у = 2, z[10];
	int *ip;		//ip - указатель на int
	ip = &x;		//теперь ip указывает на х
	y = *ip;		//у теперь равен 1
	*ip = 0;		//х теперь равен 0
	ip = &z[0];		//ip теперь указывает на z[0]
```
Если указатель `*ip` указывает на `x` , то `*ip` можно использовать в любом месте, где допустимо применение `х`.

пример:
```C
	*ip = *ip+ 10;
```
Унарные операторы `*` и `&` имеют более высокий приоритет, чем арифметические операторы, так что присваивание. Но унарные операторы `*` и `++` имеют одинаковый приоритет и порядок выполнения — справа налево.

пример:
```C
	у = *ip + 1
	*ip += 1
	(*ip)++
	*ip++ 		//увеличится значение самого указателя
```
И наконец, так как указатели сами являются переменными, в тексте они могут встречаться и без оператора косвенного доступа.

пример:
```C
	iq = ip
```



## ## Указатели и аргументы функций

Функции в Си в качестве своих аргументов получают значения параметров, нет прямой возможности, находясь в вызванной функции, изменить переменную вызывающей функции. Аргументы-указатели позволяют функции осуществлять доступ к объектам вызвавшей ее программы и дают возможность изменить эти объекты.

пример:
```C
	void swap (int x, int y) { 		//неверно
		int temp;
		temp = x;
		x = y;
		y = temp;
		}
	void swap (int *px, int *py) {	//верно
		int temp;
		temp = *рх;
		*рх = *py;
		*рy = temp;
	}
	swap(&a, &b);					//использование
```
Так как оператор `&` получает адрес переменной, `&a` есть указатель на `a`. В самой же функции `swap` параметры должны быть объявлены как указатели, при этом доступ к значениям параметров будет осуществляться косвенно.




## ## Адресная арифметика

Под адресной арифметикой понимаются действия над указателями, связанные с использованием адресов памяти. Рассмотрим операции, которые можно применять к указателям, попутно заметив, что некоторые из них уже рассматривались, однако здесь мы повторимся, для систематизации изложения материала.

Соединение указателей, массивов и адресной арифметики — одна из сильных сторон Си. Для операций над указателями их нужно сначала инициализировать осмысленными значениями.

### Инициализация.

**Первый способы**:
Описать переменные программы. Поскольку компилятор отводит память под переменную в момент ее описания, то присваивание указателю адреса переменной гарантирует, что нужная память отведена и там будут находиться значения переменных.

пример:
```C
	float a;
	float *p = &a;
	char buf[10];
	char *p;
	p = buf;
	p = &buf[4];
```
**Второй**:
присвоить указателю значение другого указателя, к этому моменту уже правильно инициализированного.

пример:
```C
	float *i = p;
```
**Третий**:
использовать одну из встроенных функции распределения памяти.

пример:
```C
	#include <stdio.h>
	#include <stdlib.h>
	void main() {
		int *b =  malloc (10*sizeof(int));
		if (b == 0){
			//error, память не выделилась
		}else{
			int i;
			for (i=0; i< 10; i++)
				printf("0x%x\n", &b[i]);
		}
	}
```
пример:
```C
	char *p, *pp;
	char buf[10];
	int array[8];
	p = buf;
	p = &buf[4];
	p = 0x0;
	p = 0xE040;			//error
	p = (char*) 0x4100;
	p = array;			//error
	p = pp;
```

###	Операции.

1. **Присваивание**. Указателю можно присвоить значение адреса. Любое число, присвоенное указателю, трактуется как адрес памяти:

	пример:
	```C
		int *u, *adr;
		int N;
		u = &N;					//указателю присвоен адрес переменной N
		adr = (int *) 0х00FD;	//указателю присвоен 16-теричный адрес
	```
2. **Взятие адреса**. Так как указатель является переменной, то для получения адреса памяти, где расположен указатель, можно использовать операцию взятия адреса `&`

	пример:
	```C
		int *a,*b;
		a = &b;					//указателю a присвоен адрес указателя b
	```
3. **Косвенная адресация**. Для того, чтобы получить значение, хранящееся по адресу, на который ссылается указатель, или послать данное по адресу, используется операция косвенной адресации `*`

	пример:
	```C
		int *p, n, m = 5;
		p = &m;					//адрес переменной m
		n = *p;					//переменная n принимает значение m
		*p = -13;				//переменная m принимает значение -13
	```
4. **Преобразование типа**. Указатель на объект одного типа может быть преобразован в указатель на другой тип. При этом следует учитывать, что объект, адресуемый преобразованным указателем, будет интерпретироваться по-другому. Операция преобразования типа указателя применяется в виде

		(<тип> *) <указатель>

	пример:
	```C
		int i, a, *ptr;
		i = 0x8e41;
		ptr = &i;
		a = *ptr;				//a = 0x8e41
		a = *((char *)ptr);		//a = 0x41
	```
	Преобразование типа указателя чаще всего применяется для приведения указателя на неопределенный тип данных `void` к типу объекта, доступ к которому будет осуществляться через этот указатель.


5. **Определение размера**. Для определения размера указателя можно использовать операцию размер в виде `sizeof(<указатель>)`. Размер памяти, отводимой компилятором под указатель, зависит от модели памяти. Для близких указателей операция `sizeof` дает значение 2(байт), для дальних 4(байт).
	
	пример:
	```C
		type *p
		sizeof(*p) = sizeof(type)	//размер типа переменной
		sizeof(p) = sizeof(address)	//разрядности шины адреса системы
	```
6. **Сравнение**. Сравнение двух указателей любой из операций отношения имеет смысл только в том случае, если оба указателя адресуют общий для них объект, например, строку или массив.

	пример:
	```C
		pbuf = buf[4];
		ptr = 0xE450;
		if (pbuf > ptr) ...  	//результат сравнения непредсказуем 
	```
7. **Индексация**. Указатель может индексироваться применением к нему операции индексации, обозначаемой в Си квадратными скобками `[ ]`. Индексация указателя имеет вид `<указатель>[<индекс>]`, где <индекс> записывается целочисленным выражением.

	Возвращаемым значением операции индексации является данное, находящееся по адресу, смещенному в большую или меньшую сторону относительно адреса, содержащегося в указателе в момент применения операции. Этот адрес определяется так: 

		(адрес в указателе) +
		(значение <индекс>) * sizeof(<тип>)

	пример:
	```C
		char *ptext;
		ptext[2] = ' ';			//ptext + 2*sizeof(char) = ptext + 2*1
	```

8. **Сложение\Вычитание**. Одним из операндов операции может быть указатель, а другим операндом обязательно должно быть выражение целого типа. Операция вырабатывает адрес, который определяется следующим образом:
	
		(адрес в указателе) +
		(значение int_выражения) * sizeof (<тип>)

	где `<тип>` это тип данных, на которые ссылается указатель.
	
	пример:
	```C
		double *pd;
		pd += 4;	//адрес увеличится на 4*sizeof(double) = 4*8 = 32, не на 4!
	```
9. **Увеличение/уменьшение**. Если к указателю применяется операция увеличения `++` или уменьшения `--`, то значение указателя увеличивается или уменьшается на размер объекта, который он адресует. Упрощенный вариант предыдущего пункта.

	пример:
	```C
		long long int ax, *p;
		p = &ax;	//адрес переменной ax
		p++;		//адрес увеличится на sizeof(ax), т.е. на 8, не на 1!
		p--;

		char text[] = "hello";	//текстовый массив
		char *s = text;			//адрес текстового массива
		s++;					//адрес увеличится на sizeof(char), т.е. на 1
	```
	пример сознательного обхода адресной арифметики.
	```C
		int n, *p;
		p = (long)(p) + n;	//преобразуем указатель в обычное число и делаем что хотим
	```




## ## Доп материал
- Символьные указатели функции
- Массивы указателей, указатели на указатели
- Многомерные массивы
- Инициализация массивов указателей
- Указатели против многомерных массивов
- Аргументы командной строки
- Указатели на функции
- Сложные объявления



[[след. лекция](5. структуры, битовые поля, смеси.md)]

[[в начало](README.md)]
