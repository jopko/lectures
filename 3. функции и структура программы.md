# # 3. Функции и структура программы

Содержание

1. Основные сведения о функциях
2. Внешние переменные
3. Области видимости
4. Заголовочные файлы
5. Статические переменные
6. Регистровые переменные
7. Блочная структура
8. Инициализация
9. Рекурсия
10. Препроцессор языка Си




Функции разбивают большие вычислительные задачи на более мелкие и позволяют воспользоваться тем, что уже сделано другими разработчиками, а не начинать создание программы каждый раз "с нуля". В выбранных должным образом функциях "упрятаны" несущественные для других частей программы детали их функционирования, что делает программу в целом более ясной и облегчает внесение в нее изменений.

## ## Основные сведения о функциях

Определение любой функции имеет следующий вид:

	тип-результата имя-функции (объявления аргументов)
	{
		объявления
		инструкции
	}

пример:
```C
	//функция генерации псевдослучайного числа.
	//входные параметры:	prev - предыдущее случайное число;
	//						seed - зерно для создания последовательности.
	//возвращает число типа int.

	int random (int prev, int seed)
	{
		prev = prev * 1103515245L + seed;
		return (prev >> 16);
	}
```

Этим создается некий внешний интерфейс пользователя. Отдельные части определения могут отсутствовать, как, например, в определении "минимальной" функции `foo(){}`. В исходном файле функции могут располагаться в любом порядке; исходную программу можно разбивать на любое число файлов, но так, чтобы ни одна из функций не оказалась разрезанной.

Функцию можно рассматривать как 4-х полюсник. На вход которого поступают данные в виде аргументов и внешних переменных, которые преобразуются функцией, и на выходе получается результат.

**вход**:
В блоке "объявления аргументов" необходимо через запятую указать типы и имена всех переменныех которые нужны данной функции. Если у функции нет аргументов, используйте слово `void`. Внешние переменные объявленные до функции впринципе тоже будут видны в теле функции и их можно читать\писать. Но подобные неявные связи лучше минимизировать.
```C
	(int mass, float v)
	(char str[])
	(void)
```
**имя**:
для вызова функции ей нужно придумать уникальное в пределах вашей программы имя. правила создания имен функций аналогичны правилам для имен переменных. желательно делать их осмысленными и достаточно короткими.
```C
	copyfile - копирует файл
	getname - получает имя
```
**выход**:
Механизм возврата результата реализует через инструкцию `return`. За словом return может следовать любое выражение. Функция вернет результат вычисления этого выражения.
```C
	return imp;
	return sin(pi/2);
```
При этом тип возвращаемых данных должен совпадать с типом-результата в объявлении функции. Выражение после return может отсутствовать, и тогда произойдет выход в вызывающую функцию. Вызывающая функция вправе проигнорировать возвращаемое значение.

Пример:
```C
	//задача:
	//напечатать строки, содержащие некий образец.
	//
	//решения:
	//while (существует еще строка) 		//получение строки
	//	if (строка содержит образец)		//поиск образца
	//		печать строки					//печать
	
	//разобъем задачу на подзадачи с помощью функций.
	//опишем внешние интерфейсы для работы с каждой из них:

	//-------------------------------
	//получает строку
	//и пишет ее в строку s
	//возвращает длину
	//-------------------------------
	int getline (char s[], int lim)
	{...}

	//-------------------------------
	//ищет строку
	//возвращает место строки t в строке s
	//если не находит, возвращает -1
	//-------------------------------
	int strindex (char s[], char t[])
	{...}

	//-------------------------------
	//печатает строку s
	//ничего не возвращает
	//-------------------------------
	void print(char s[])
	{...}
```


## ## Внешние переменные

Прилагательное "внешний" (`external`) противоположно прилагательному "внутренний" (`internal`), которое относится к аргументам и переменным, определяемым внутри функций. Внешние переменные определяются вне функций и потенциально доступны для многих функций. Поскольку внешние переменные доступны всюду, их можно использовать в качестве связующих данных между функциями как альтернативу связей через аргументы и возвращаемые значения. Для любой функции внешняя переменная доступна по ее имени, если это имя было должным образом объявлено.

пример:
```C
	int a;
	
	void check (void){
		if (a == 1)    ...
	}
	
	void set (void){
		a = 1;
	}
	
	main () {
		set();
		check();
	}
```
Если число переменных, совместно используемых функциями, велико, связи между последними через внешние переменные могут оказаться более удобными и эффективными, чем длинные списки аргументов. Но такая практика ухудшает структуру программы и приводит к слишком большому числу связей между функциями по данным. Внешние переменные полезны, так как они имеют большую область действия и время жизни. Автоматические переменные существуют только внутри функции, они возникают в момент входа в функцию и исчезают при выходе из нее. Внешние переменные, напротив, существуют постоянно, так что их значения сохраняются и между обращениями к функциям.



## ## Области видимости

Исходный текст может быть довольно протяженным, или храниться в нескольких файлах, библиотеках. В связи с этим возникает вопрос: как функции находят необходимые им переменные\функции? Ответ: по именам. Но у каждого имени есть своя область видимости.

Областью видимости имени считается часть программы, в которой это имя можно использовать. Для автоматических переменных, объявленных в начале функции, областью видимости является функция, в которой они объявлены. Локальные переменные разных функций, имеющие, однако, одинаковые имена, никак не связаны друг с другом. Параметры функции, тоже фактически являются локальными переменными.

пример:
```C
	int func (char s)
	{
		int i;	//s,i - локальные переменные, не видны за пределами функции
	}
```
Область действия внешней переменной или функции простирается от точки программы, где она объявлена, до конца файла.
Однако, если на внешнюю переменную нужно сослаться до того, как она определена, или если она определена в другом файле, то ее объявление должно быть помечено словом extern.

пример:
```C
	func (a);	//ошибка, переменная не найдена
	char a;
	func (a);
```
Важно отличать объявление внешней переменной от ее определения. Объявление объявляет свойства переменной (прежде всего ее тип), а определение, кроме того, приводит к выделению для нее памяти. До выделения памяти переменной физически не существуют. 	Объявление должно быть только одно, определений может быть сколько угодно. В определениях массивов необходимо указывать их размеры, что в объявлениях extern не обязательно.

пример:
```C
	int sp;					//создаем переменную sp
	double val[MAXVAL];

	extern int sp;			//говорим, что где-то существует переменная sp
	extern double val[];
```

## ## Заголовочные файлы

Если программа состоит из множества файлов, или подключаются библиотеки, то объявления отделяют от определений, распологая их в разных файлах. Файлы с определениями называются заголовочными и похожи скорее на сожержание книги. где показывается что где имеется и как к этому обратиться. Заголовочные файлы обычно имеют расширение h.

пример:
```C
	//файл math.h
	extern float pi;
	float cos (float);
	
	//файл match.c
	float pi = 3.14;
	float cos (float a){ 
		...
	}
	
	//файл main.c
	#include <math.h>
	main () {
		float a;
		a = cos (pi/2);
	}
```

## ## Статические переменные

Указание static, примененное к внешней переменной или функции, ограничивает область видимости соответствующего объекта концом файла. Это способ скрыть имена. Как следствие этими именами можно свободно пользоваться в других файлах для совсем иных целей.

пример:
```C
	static char buf[BUFSIZE];		//входной буфер, скрытый от посторонних глаз
	int getchar(void) { ... }		//функция чтения буфера
```
Указание static чаще всего используется для переменных, но с равным успехом его можно применять и к функциям. Обычно имена функций глобальны и видимы из любого места программы. Если же функция помечена словом static, то ее имя становится невидимым вне файла, в котором она определена.

Объявление static можно использовать и для внутренних переменных. Как и автоматические переменные, внутренние статические переменные локальны в функциях, но в отличие от автоматических они не возникают только  на  период  работы  функции,  а  существуют  постоянно.  Это  значит,  что  внутренние  статические переменные обеспечивают постоянное сохранение данных внутри функции.

пример:
```C
	int in_count (void) {	//подсчитывает сколько раз ее запускали
		static int i=0;
		return i++;
	}
```
Внешние статические переменные и функции предоставляют способ организовывать данные и работающие с ними внутренние процедуры таким образом, что другие процедуры и данные не могут прийти с ними в конфликт даже по недоразумению.




## ## Регистровые переменные

Объявление register сообщает компилятору, что данная переменная будет интенсивно использоваться. Идея  состоит  в  том,  чтобы  переменные,  объявленные register,  разместить  на  регистрах  машины, благодаря чему программа, возможно, станет более короткой и быстрой. Однако компилятор имеет право проигнорировать это указание. Объявление register может применяться только к автоматическим переменным и к формальным параметрам функций

пример:
```C
	int func (register long id) {
		register int i;
		...
	}
```
## ## Блочная структура

Поскольку функции в Си нельзя определять внутри других функций, он не является языком, допускающим блочную структуру программы  в том смысле, как это допускается в Паскале и подобных ему языках.
Но переменные внутри функций можно определять в блочно-структурной манере.

Объявления переменных (вместе с инициализацией) разрешено помещать не только в начале функции, но и после  любой  левой фигурной скобки, открывающей составную инструкцию. Переменная, описанная таким способом, "затеняет" переменные  с  тем  же  именем,  расположенные  в  объемлющих  блоках,  и  существует  вплоть  до соответствующей правой фигурной скобки.

пример:
```C
	{
		int a = 3;		//a=3
		if (..) {
			int a = 1;	//a=1	затенение
		}
		..				//a=3
	}
```
## ## Инициализация

При отсутствии явной инициализации для внешних и статических переменных гарантируется их обнуление; автоматические  и  регистровые  переменные  имеют  неопределенные  начальные  значения  ("мусор"). Скалярные переменные можно инициализировать в их определениях,  помещая после имени знак `=`  и соответствующее выражение:

пример:
```C
	int x = 1;
	char squote = '\'';
	long day = 1000L * 60L * 60L * 24L;
```
Для внешних и статических переменных инициализирующие выражения  должны быть константными, при этом инициализация осуществляется  только один раз до начала выполнения программы. Инициализация автоматических и регистровых переменных выполняется каждый раз при входе в функцию или блок. Для таких переменных инициализирующее выражение — не обязательно константное. Это может быть любое выражение, использующее ранее определенные значения, включая даже и вызовы функций.

пример:
```C
	int func (int n) {
		int low = 0;
		int high = n - 1;
		int mid;
		..
	}
```
Массив можно инициализировать в его определении с помощью заключенного в фигурные скобки списка инициализаторов,  разделенных  запятыми. Если  размер  массива  не  указан,  то  длину  массива  компилятор  вычисляет  по  числу  заданных инициализаторов;

пример:
```C
	int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
```
Инициализация символьных массивов —  особый случай: вместо конструкции с фигурными скобками и запятыми можно использовать строку символов.

пример:
```C
	char text[] = "abc";
	char text[] = {'a','b','c','\0'};
```



## ## Рекурсия

В Си допускается рекурсивное обращение к функциям, т.е. функция может обращаться сама к себе, прямо или косвенно. Когда  функция  рекурсивно  обращается  сама  к  себе,  каждое  следующее  обращение  сопровождается получением ею нового полного набора автоматических переменных, независимых от предыдущих наборов.

пример:
```C
	//функция считывания файлов из директории.
	//Если она считывает что в папке есть папка
	//то рекурсивно считывает файлы и из неё
	//и так далее в самую глубину

	рекурсивное чтение
		есть папки?
			зайти в папку
			рекурсивное чтение
		чтение файлов
		выход
```
Если процедура вызывает сама себя, то, по сути, это приводит к повторному выполнению содержащихся в ней инструкций, что аналогично работе цикла.

пример:
```C
	//функция выполнит некий код n раз
	
	void mywhile (int n)
	{
  		if (n) {
			//какой-то код здесь
			n--;
			mywhile(n);
		}
		else
			return;
	}
```

## ## Препроцессор языка Си

Некоторые возможности языка Си обеспечиваются препроцессором,  который работает на первом шаге компиляции.  Наиболее  часто  используются  две  возможности:  `#include`,  вставляющая  содержимое некоторого файла во время компиляции, и `#define`, заменяющая одни текстовые последовательности на другие. В этом параграфе обсуждаются условная компиляция и макроподстановка с аргументами.



###  Включение файла

Любая строка вида
```C
	#include "имя-файла"
	#include <имя-файла>
```
заменяется содержимым файла с именем имя-файла. Если имя-файла заключено в двойные кавычки, то, как правило, файл ищется среди исходных файлов программы; если такового не оказалось или имя-файла заключено в угловые скобки `<`  и `>`, то поиск осуществляется по определенным в реализации правилам. Включаемый файл сам может содержать в себе строки `#include`.

Средство `#include` — хороший способ собрать вместе объявления большой программы. Он гарантирует, что все исходные файлы будут пользоваться одними и теми же определениями и объявлениями переменных, благодаря чему предотвращаются особенно неприятные ошибки. Естественно, при внесении изменений во включаемый файл все зависимые от него файлы должны перекомпилироваться.



### Макроподстановка

Определение макроподстановки имеет вид:
```C
	#define имя замещающий-текст
```
Макроподстановка используется для простейшей замены: во всех местах,  где встречается лексема имя, вместо нее будет помещен замещающий-текст. Имена в `#define` задаются по тем же правилам, что и имена обычных переменных. Замещающий текст может быть произвольным. Область видимости имени, определенного в  `#define`, простирается от данного определения до конца файла. В определении макроподстановки могут фигурировать более ранние `#define`-определения.

Подстановка  осуществляется  только  для  тех  имен,  которые  расположены  вне  текстов,  заключенных  в кавычки.  Например,  если `YES`  определено  с  помощью `#define`,  то  никакой  подстановки  в  `printf("YES")` или в `YESMAN` выполнено не будет. Любое имя можно определить с произвольным замещающим текстом

пример:
```C
	#define forever for(;;)
	#define max(A, В) ((А)>(В) ? (А):(В))
```
Действие `#define` можно отменить с помощью `#undef`


### Условная компиляция

Самим ходом препроцессирования можно управлять с помощью условных инструкций. Они представляют собой средство для выборочного включения того или иного текста программы в зависимости от значения условия, вычисляемого во время компиляции.

Если выражение имеет ненулевое значение,  то  будут  включены  все  последующие  строки  вплоть  до `#endif`,  или  `#elif`,  или  `#else`.

пример:
```C
	#if выражение
		..
	#elseif выражение
		..
	#else
		..
	#endif
```
пример:
```C
	#if !defined(HDR)
		#define HDR
		/* здесь содержимое hdr.h */
		..
	#endif
```












