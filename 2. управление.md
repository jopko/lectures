3 Управление
3.1 Инструкции и блоки
3.2 Конструкция if-else
3.3 Конструкция else-if
3.4 Переключатель switch
3.5 Циклы while и for
3.6 Цикл do-while
3.7 Инструкции break и continue
3.8 Инструкция goto и метки


Инструкции управления определяет порядок, в котором выполняются вычисления.




3.1 Инструкции и блоки
	вычисления сгруппированы в блоки последовательно выполняемых инструкций. одиночная инструкция это выражение в конце которого стоит ;
	пример:
		int y;
		х = 0;
	чтобы с точки зрения синтаксиса группа инстукций и объявлений воспринималась как одна составная инстукция\ блок, используются фигурные скобки {..}





3.2 Конструкция if-else

	if (выражение)	инструкция1
	else			инструкция2

	Сначала вычисляется выражение, и, если оно истинно (т. е. отлично от нуля), выполняется инструкция1. Если выражение ложно (т. е. его значение равно нулю) и существует else-часть, то выполняется инструкция2. else-часть может и отсутствовать.
	Так как проверяется именно числовое значение выражения, то в нем допускаются разнообразные сокращенния и извращения. Иногда это даже удобно.
	пример:
		(выражение != 0) -> (выражение)
	совет:
		вложенные конструкции обрамляйте фигурными скобками, т.к. в случае отсутствия else возможны ошибки, которые трудно обнаружить.
		if (a) {
			if (b) {..}
			else {..}
		} else {..}





3.3 Конструкция else-if
	Частый способ описания принятия многоступенчатого решения. Выражения вычисляются по порядку. Как только встречается выражение со значением "истина", выполняется соответствующая ему инструкция. На этом последовательность проверок завершается.

		if (выражение)
			инструкция
		else if (выражение)
			инструкция
		else if (выражение)
			инструкция
		else if (выражение)
			инструкция
		else
			инструкция

	Последняя else-часть срабатывает, если не выполняются все предыдущие условия. Ее часто используют для фиксации ошибочной ("невозможной") ситуации.
	пример:
		вычисление значения кусочно заданной функции





3.4 Переключатель switch
	Инструкция switch используется для выбора одного из многих путей. Она проверяет, совпадает ли значение выражения с одной из констант (или константных выражений) и выполняет соответствующую этому значению ветвь программы.

		switch (выражение) {
			case конст1: инструкция1
			case конст2: инструкция2
			default: инструкция3
		}

	Ветви case и default можно располагать в любом порядке.
	пример:
		подсчет кол-ва цифр в строке.

	switch по сути состоит из двух частей: конструкции else-if, которая осуществляет поиск и переход на нужную метку, и собственно самих инструкций.

		if (выражение == конст1) 		переход на инструкцию1
		else if (выражение == конст2)	переход на инструкцию2
		else							переход на инструкцию3
		{	инструкция1
			инструкция2
			инструкция3
		}

	После выполнения одной ветви case, если ничего не предпринять, программа провалится вниз на следующую ветвь. Для прерывания этой последовательности (т.е. выхода из switch) чаще всего используют инструкции break и return.

	упражнение:
		напишите код, который бы заменял пробелы в строке на знак подчеркивания.






3.5 Циклы while и for

	общий алгоритм работы цикла:
		1. проверить некое условие
		2. если ложно, выйти из цикла
		3. если истинно, выполнить инструкцию
		4. перейти на пункт 1

	как видим алгоритм не сложный и можно самостоятельно его реализовать, но обычно в составе языка уже имеются конструкции для его записи.

	while (выражение)
		инструкция

	for (выр1; выр2; выр3)
		инструкция

	эквивалент
	выр1; 				//начальное состояние
	while (выр2) { 		//условие завершения
		инструкция
		выр3;			//изменение состояния
	}

	Любое из этих трех выражений может отсутствовать, но точку с запятой опускать нельзя. При отсутствии выр1 или выр3 считается, что их просто нет в конструкции цикла; при отсутствии выр2 предполагается, что его значение как бы всегда истинно. пример:
		for (;;)		//бесконечный цикл

	способы выхода из любого цикла, даже бесконечного:
	- при проверке выр2 оказывается ложным (равным 0).
	- выполнение инструкций break или return.
	- выполнение инструкции безусловного перехода goto (против лома нет приема)

	Какой цикл выбрать: while или for? Это скорее дело вкуса. Например, когда нет ни инициализации, ни пересчета параметра, больше подходит while. Там, где есть простая инициализация и пошаговое увеличение значения некоторой переменной, больше подходит цикл for, так как организующая его часть удобно сосредоточена в его теле.
	пример:
		for (i = 0; i < n; i++)		//последовательный перебор

	Это похоже на DO-циклы в Фортране и for-циклы в Паскале. Сходство, однако, не вполне точное, так как в Си индекс и его предельное значение могут изменяться внутри цикла, и значение индекса i после выхода из цикла всегда определено.

	совет:
		Поскольку три компоненты цикла могут быть произвольными выражениями, организация fоr-циклов не ограничивается только случаем арифметической прогрессии. Однако включать в заголовок цикла вычисления, не имеющие отношения к инициализации и инкрементированию, считается плохим стилем. Заголовок лучше оставить только для операций управления циклом.



	Доп. материал:
		запятые в выражениях при инициализации цикла
		выр; -> вырА, вырБ, вырВ;







3.6 Цикл do-while
	В Си имеется еще один вид цикла, в котором условия окончания, в отличие от while и for, делается внизу после каждого прохождения тела цикла.
	cинтаксис:
		do
			инструкция
		while (выражение);

	Сначала выполняется инструкция, затем вычисляется выражение. Если  оно  истинно,  то  инструкция выполняется снова. Цикл do-while  используется реже, чем  while  и for. Тем не  менее, потребность в нем имеется.











3.7 Инструкции break и continue
	Иногда бывает удобно выйти из цикла не по результату проверки, осуществляемой в начале или в конце цикла, а каким-то другим способом. Инструкция break позволяет выйти для циклов for, while и do-while и переключателя switch. В случае вложенности циклов\переключателей выход осуществляется только из ближайшего.

	пример:
		удалние пустых символов (пробелов) в конце строки, выход по первому значащему символу.
		int trim (char s[]) {
			int n;
			for (n = strlen(s)-1; n >= 0; n--)
				if (s[n] != ' ')
					break;
			s[n+1] = '\0';
			return n;
		}

	Инструкция continue в чем-то похожа на break, но применяется гораздо реже. Она вынуждает ближайший объемлющий ее цикл (for, while или do-while) начать следующий шаг итерации. Для while и do-while это означает немедленный переход к проверке условия, а для for  —  к приращению шага. Инструкцию continue  можно  применять  только  к  циклам,  но  не  к switch.  Внутри  переключателя  switch, расположенного в цикле, она вызовет переход к следующей итерации этого цикла.

	пример:
		for () {
			switch ()
				case A:
				case B: continue
		}

		for (i=0 ; i<n; i++) {
			if (a[i] < 0) continue;	//пропуск отрицательных элементов
									//обработка положительных элементов
		}







3.8 Инструкция goto и метки
	В Си имеются порицаемая многими инструкция goto и метки для перехода на них. Строго говоря, в этой инструкции нет никакой необходимости, и на практике почти всегда легко без нее обойтись.
	Однако существуют случаи, в которых goto может пригодиться. Наиболее типична ситуация, когда нужно прервать обработку в некоторой глубоко вложенной структуре и выйти сразу из двух или большего числа вложенных циклов.

	пример:
		for () {
		for () {
		for () {
			..
			if ( )			//если бедствие
				goto error;	//уйти на ошибку
		}}}
		error:	//обработка ошибки

	Плюсы: быстрее работает, меньше ресурсов требует;
	Минусы: сложнее в сопровождении, понимании, отладке.

	Goto очень мощный инструмент и в этом его слабость. В неумелых руках может натворить много бед. В скрытом виде содержиться практически во всех управляющих конструкциях (и не только управляющих).

















