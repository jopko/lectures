# # 2. Управление

Содержание

1. ва
2. ва
3. ва



Инструкции управления определяют порядок, в котором выполняются вычисления.


## ##  Инструкции и блоки
вычисления сгруппированы в блоки последовательно выполняемых инструкций. одиночная инструкция это выражение в конце которого стоит ;

пример:

	int y;		//создание переменной y, выделение ей памяти
	х = 0;		//запись нуля в переменную x

чтобы с точки зрения синтаксиса группа инстукций и объявлений воспринималась как одна составная инстукция\ блок, используются фигурные скобки {..}


## ##   Конструкция if-else

	if (выражение)	инструкция1
	else			инструкция2

Сначала вычисляется выражение, и, если оно истинно (т. е. отлично от нуля), выполняется инструкция1. Если выражение ложно (т. е. его значение равно нулю) и существует `else`-часть, то выполняется инструкция2. `else`-часть может и отсутствовать.

Так как проверяется именно числовое значение выражения, то в нем допускаются разнообразные сокращенния и извращения. Иногда это даже удобно.

пример:

	(выражение != 0) -> (выражение)

совет:
вложенные конструкции обрамляйте фигурными скобками, т.к. в случае отсутствия `else` возможны ошибки, которые трудно обнаружить.

	if (a) {
		if (b) {..}
		else {..}
	} else {..}





## ##  Конструкция else-if

Частый способ описания принятия многоступенчатого решения. Выражения вычисляются по порядку. Как только встречается выражение со значением "истина", выполняется соответствующая ему инструкция. На этом последовательность проверок завершается.

	if (выражение)
		инструкция
	else if (выражение)
		инструкция
	else if (выражение)
		инструкция
	else if (выражение)
		инструкция
	else
		инструкция

Последняя `else`-часть срабатывает, если не выполняются все предыдущие условия. Ее часто используют для фиксации ошибочной ("невозможной") ситуации.

пример:

	//вычисление значения кусочно заданной функции
	...





## ##  Переключатель switch

Инструкция `switch` используется для выбора одного из многих путей. Она проверяет, совпадает ли значение выражения с одной из констант (или константных выражений) и выполняет соответствующую этому значению ветвь программы.

	switch (выражение) {
		case конст1:
			инструкция1
		case конст2:
			инструкция2
		default:
			инструкция3
	}

Ветви `case` и `default` можно располагать в любом порядке.

пример:

	//подсчет кол-ва цифр в строке.
	...

`switch` по сути состоит из двух частей: конструкции `else-if`, которая осуществляет поиск и переход на нужную метку, и собственно самих инструкций.

	if (выражение == конст1)
		инструкция1
	else if (выражение == конст2)
		инструкцию2
	else
		инструкцию3

После выполнения одной ветви `case`, если ничего не предпринять, программа провалится вниз на следующую ветвь. Для прерывания этой последовательности (т.е. выхода из `switch`) чаще всего используют инструкции `break` и `return`.

пример:
	
	//замеряем пробелы в строке на знак подчеркивания
	...




## ##  Инструкция goto и метки

В Си имеются порицаемая многими инструкция безусловного перехода `goto` и метки. Метки это что-то типо закладок, куда оператор `goto` может делать переходы. В ассемблере это очень расспространенная вещь. Причем существует огромное множество этих инструкций перехода: условные, безусловные, дальние, ближние, с автоинкрементом и т.д.

пример

	jmp			//ассемблерная инструкция безусловного перехода

Строго говоря, в Си в этой инструкции нет никакой необходимости, и на практике почти всегда можно без нее легко обойтись.

Но существуют случаи, в которых goto может пригодиться. Наиболее типична ситуация, когда нужно прервать обработку в некоторой глубоко вложенной структуре.

пример:

		if () {
		if () {
		if () {
			...
			if ( )			//если ошибка
				goto error;	//перейти к обработчику ошибки
		}}}
		error:	
			...				//обработчик ошибки

Плюсы: быстрее; работает; меньше ресурсов требует;
Минусы: сложнее в сопровождении, понимании, отладке.

В скрытом виде `goto` содержиться практически во всех управляющих конструкциях (и не только управляющих).



## ##  Циклы
Что делать, если вам нужно запрограммировать какое то повторяющееся действие ? 

пример

	//отслеживаем состояния регистра reg,
	//и как только reg станет равным 0,
	//выполняем важную инструкцию launch
	
	if (reg == 0) 				//отслеживаем состояния
		launch;					//важная инстукция
	if (reg == 0)				//отслеживаем состояния
		launch;					//важная инстукция
	if (reg == 0)				//отслеживаем состояния
		launch;					//важная инстукция
		....

Получилось не очень красиво. Ситуацию можно улучшить с помощью меток и безусловных переходов `goto`. 

пример

	myloop:						//метка начала цикла
			if (reg == 0) {		//отслеживаем состояния
				launch;			//важная инстукция
			}
			goto myloop;		//повторить (перейти в начало)

но обычно для организации циклов пользуются более удобными средствами.

### цикл while
синтаксис
	
	while (выр1) {
		...				//инструкция
	}

алгоритм работы:

	loop:				//метка начала цикла
	if (выр1) {			//если выр1 истинно
		...				//выполнить полезный код
		goto loop;		//повторить
	}					//иначе, выйти из цикла


### цикл for
синтаксис

	for (выр1; выр2; выр3) {
		...				//инструкция
	}

алгоритм работы:

	выр1; 				//начальное состояние
	while (выр2) { 		//условие завершения
		...				//инструкция
		выр3;			//изменение состояния
	}

Любое из этих трех выражений может отсутствовать, но точки с запятой опускать нельзя. При отсутствии выр1 или выр3 считается, что их просто нет в конструкции цикла; при отсутствии выр2 предполагается, что его значение как бы всегда истинно. пример:

	for (;;) {		//бесконечный цикл
		...			//инструкция
	}

эквивалент
	
	while (1) {		//бесконечный цикл
		...			//инструкция
	}

способы выхода из любого цикла, даже бесконечного:

- при проверке выр2 оказывается ложным (равным 0).
- выполнение инструкций break или return.
- выполнение инструкции безусловного перехода goto (против лома нет приема)

Какой цикл выбрать: `while` или `for` ? Это скорее дело вкуса. Например, когда нет ни инициализации, ни пересчета параметра, больше подходит `while`. Там, где есть простая инициализация и пошаговое увеличение значения некоторой переменной, больше подходит цикл `for`, так как организующая его часть удобно сосредоточена в его теле.

пример:

	for (i = 0; i < n; i++)		//последовательный перебор

Это похоже на `do` циклы в Фортране и `for` циклы в Паскале. Сходство, однако, не вполне точное, так как в Си индекс и его предельное значение могут изменяться внутри цикла, и значение индекса i после выхода из цикла всегда определено.

совет: Поскольку три компоненты цикла могут быть произвольными выражениями, организация `fоr` циклов не ограничивается только случаем арифметической прогрессии. Однако включать в заголовок цикла вычисления, не имеющие отношения к инициализации и инкрементированию, считается плохим стилем. Заголовок лучше оставить только для операций управления циклом.

Доп. материал:
запятые в выражениях при инициализации цикла
выр; -> вырА, вырБ, вырВ;





###  Цикл do-while

В Си имеется еще один вид цикла, в котором условия окончания, в отличие от `while` и `for`, делается внизу после каждого прохождения тела цикла.

cинтаксис:

	do {
		...		//инструкция
	}
	while (выр);

алгоритм работы
	
	myloop:	{
				...		//инструкция
			}
			if (выр)
				goto myloop;

Сначала выполняется инструкция, затем вычисляется выражение. Если  оно  истинно,  то  инструкция выполняется снова. Цикл `do-while`  используется реже, чем  `while`  и `for`. Тем не  менее, потребность в нем имеется.





## ## Инструкции break и continue

Иногда бывает удобно выйти из цикла не по результату проверки, осуществляемой в начале или в конце цикла, а каким-то другим способом. Инструкция `break` позволяет выйти для циклов `for`, `while` и `do-while` и переключателя `switch`. В случае вложенности циклов\переключателей выход осуществляется только из ближайшего.

пример:
	
	for (;;) {		//бесконечный цикл
		...			//инструкция
		
		if (выр)	
			break;	//выход из бесконечного цикла
	}


пример (сложный):

	//удалние пустых символов (пробелов) в конце строки,
	//выход по первому значащему символу.
	
	int trim (char s[]) {
		int n;
		for (n = strlen(s)-1; n >= 0; n--)		//начиная с конца строки 
			if (s[n] != ' ')					//символ не пробел ?
				break;							//выходим из цикла
		s[n+1] = '\0';							//ставим признак конца строки
		return n;								//возвращаем новую длину
	}

Инструкция `continue` в чем-то похожа на `break`, но применяется гораздо реже. Она вынуждает ближайший объемлющий ее цикл (for, while или do-while) начать следующий шаг итерации. Для `while` и `do-while` это означает немедленный переход к проверке условия, а для `for`  —  к приращению шага. Инструкцию `continue`  можно  применять  только  к  циклам,  но  не  к `switch`.  Внутри  переключателя  `switch`, расположенного в цикле, она вызовет переход к следующей итерации этого цикла.

пример:

	for (i = 0 ; i < n; i++) {
		if (i == 13)			//13 номер?
			continue;			//пропускаем, переходим к следующему
		...						//инструкции
	}






















