
# лекция 1. переменные, типы данных, операторы и выражения


## переменные
переменная — поименованная, либо адресуемая иным способом область памяти, адрес которой можно использовать для осуществления доступа к данным и изменять значение в ходе выполнения программы (с) вики.

### имена
Cуществуют ограничения на задание имен переменных и именованных констант. Имена составляются из букв и цифр; первым символом должна быть буква. Символ подчеркивания (`_`) считается буквой. Соглашения об именах, разные стандарты записи. Максимум 31 символ.


совет : давайте _осмысленные_ имена, соответствующие назначению. для локальных переменных лучше короткие имена, для внешних - более длинные.


### типы данных

| название | описание | размер
----------------- | ---------------------------- | ------------------
| `char`	| целое цисло или код символа | 1
| `int`	| целое число, отображает естественное представление целых чисел в машине (размер зависит от машины)| 2 ?
| `float`	| число с плавающей точкой одинарной точности | 2
| `double`	| число с плавающей точкой двойной точности | 4

совет : для определения размера используйте макрос `sizeof`



### квалификаторы
| название | описание | применимо к типам
----------------- | ---------------------------- | ------------------
| `const` | указание на то, что значение переменной не должно меняться | all
| `signed` | знаковая перменная | int, char
| `unsigned` | беззнаковая | int, char
| `short` | короткое целое число, *size 16 bit* | int, char
| `long` | длинное целое число, *size 32 bit* | int, double
| `long long` | очень длинное, *size 64 bit* | int

совет : если вам не хватает двойной точности double, используйте long double.



## представление данных

### представление чисел
Числа типа long завершается буквой `l` или `L`.
Беззнаковые числа заканчиваются буквой `u` или `U`.
Можно использовать больше одного модификатора, например, `UL`, `ul`, `Ul`, `Lu`.
Числа с плавающей точкой имеют десятичную точку (`.`).
Окончание `f` или `F` указывает на тип float.
Если у них нет окончания, считается, что они принадлежат к типу double.

пример:

	12         //число, минимально необходимый тип char
	1234       // - short int
	1234L      // - long int
	123.4      // - double
	123.4f     // - float
	1е-2       // - double

Целое значение помимо десятичного может иметь восьмеричное или шестнадцатеричное. Если константа начинается с нуля (`0`), то она представлена в восьмеричном виде, если с (`0х`) или с (`0Х`), то — в шестнадцатеричном.

пример :

	0x0      // число 0
	0x9      // 9
	0xA      // 10
	0xB      // 11
	0xF      // 15
	0x10     // 16
	0xFFFF   // 65535


### представление символов и строк
Для машины символ - это просто число. Существуют таблицы кодировок, словари, в которых печатным и не печатным символам сопоставлены числовые коды.
Одна из распространенных `ASCII`. Она создавалась для обмена информацией по телетайпу. В набор были включены непечатаемые символы, используемые как команды для управления устройством телетайп. Аналогичные команды применялись и в других докомпьютерных средствах обмена сообщениями (`азбука Морзе`, `семафорная азбука`), учитывали специфику устройства.

#### Символы
Типы символов:

- десятичных цифр;
- латинского алфавита;
- национального алфавита;
- знаков препинания;
- управляющих символов.

Язык С поддерживает таблицы кодировок и берет на себя задачу перекодирования символов в машиные коды. Для записи символа нужно окружить его одинарными ковычками `'символ'`. в поле _сивмол_ пишется символ.

пример :

	//десятичные цифры
	'0'       //символ 0, не есть 0, обычно имеет код 0x30
	'1'       //символ 1, не есть 1, обычно имеет код 0x31
	'2'       //символ 3, не есть 1, обычно имеет код 0x32

	//буквы латинского алфавита
	'a'       //символ a
	'b'       //символ b
	'c'       //символ c

	//буквы национального алфавита
	'ж'       //символ а
	'ъ'       //символ б
	'й'       //символ ц

	//знаки препинания
	'.'       //символ .
	';'       //символ ;
	','       //символ ,

	//управляющие символы
	`\0`      //Конец строки
	`\n`      //Переход на новую строку
	`\t`      //Горизонтальная табуляция
	`\0`      //Конец строки

**код символа**

Для тех кто плохо воспринимает обычные символы, в языке есть возможность записать непосредственно машинный код символа. Синтаксис `'\код'`, в поле _код_ пишется целое число - числовое представление символа.

пример :

	'\0'		//код 0   символ конца строки
	'\3'		//код 3   символ конца текста
	'\32'		//код 32  символ пробела ' '
	'\48'		//код 48  символ '1'
	'\97'		//код 97  символ 'а'

#### Строки

Символы, рассмотренные нами ранее, сами по себе мало полезны, но из них можно составлять цепочки символов.

пример:

	'в', 'а', 'с', 'я'    //цепочка символов

Но есть одна проблема, в вычислительной машине рядом со строками обычно находится множество других данных, цифр, паролей, кодов программ. Как узнать, где кончается строка и начинаются данные ?

пример:

	'в', 'а', 'с', 'я' 31 04 2001 0xFFFF 0xAE04      //имя, дата рождения, еще что-то

Используют управляющий символ _конца строки_ `\0`

пример:

	'в', 'а', 'с', 'я' '\0'     //цепочка символов и индикатор конца строки

В стандарте языка С для такой конструкции есть удобная запись. Называется строка.
**Строка** - это последовательность символов, заключенных в двойные кавычки, в конце которой стоит признак окончания последовательности.

пример:

	"вася"        //'в', 'а', 'с', 'я', '\0'
	"user name"   //'u', 's', 'e', 'r', ' ', 'n', 'a', 'm', 'e', '\0'







## Объявления

### Переменные
Все переменные должны быть объявлены _раньше_, чем будут использоваться, хотя бы неявно, в контексте. Объявление специфицирует тип и содержит список из одной или нескольких переменных этого типа.

пример:

	int lower, upper, step;
	char с, line [1000];

Переменные можно распределять по объявлениям произвольным образом. Например, создав отдельное объявление для каждой переменной. Кконечно, такие объявления занимают больше места, но их удобнее модифицировать, сопровождать и комментировать.

пример:

	//вариант 1. быстрый способ объявления переменных
	type name1, name2 = .., name3;	//комментарий

	//вариант 2. удобный
	type name1;			//комментарий1
	type name2 = ... ;	//комментарий2
	type name3;			//комментарий3


В объявлении можно задать начальное значение переменной, инициализировать. А можно и не задавать, в этом случае компилятор присвоит ей значение по умолчанию, в зависимости от класса памяти переменной (auto, static, extern, register - см. 4 главу).

пример:

	double e = 2.71828182845905;



### Константы
Константы - это данные, изменение которых не предполагается. Попытка изменения вызывает ошибку компиляции.

**Неименованные константы**

Это обычные цифры, строки, символы. Их называют "магическими числами", потому что часто неочевидно откуда они берутся.

пример:
	
	y = 256;				//запись в переменную неименованной константы 256
 

**Именованные константы**

Это фактически обычные переменные, только с квалификатором const и заданным значением. Неименнованные константы часто называются "магическими числами", потому что часто непонятно откуда оно взялось.

пример:

	const int MAX = 256;	//объявление именнованной константы MAX
	y = MAX;				//запись в переменную именнованной константы

совет:

Старайтесь использовать именованные константы, они облегчают чтение, отладку и поддержку кода.
Так как исчезает необходимость помнить конкретные числа — имена запоминаются легче. Проще вносить изменения, т.к. значение константы задано в программе всего в одном месте.




**Константные выражения**

Выражения, оперирующие только с константами, называются константами. Вычисляются во время компиляции, а не во время выполнения. Их можно использовать в любом месте, где допустимы константы.

пример:

	const int CLOCK_FREQ   = 1024;				//создание константы
	const int CLOCK_PERIOD = (1/CLOCK_FREQ);	//применение ее в константном выражении
	timeout = 4 * CLOCK_PERIOD;					//установка таймаута в 4 периода

_**доп. материал**:_

константы можно создавать с помощью перечисления `enumeration`. В языке Си это список целых констант. Первое имя в списке имеет значение 0 и каждое следующее на 1 больше. Можно прерывать последовательность, самостоятельно задавая значение константы.

пример:

	enum USB_Port { USB0, USB4 = 3 };		//создание перечисления. USB0 = 0, USB4 = 3
	enum USB_Port myusb;					//создание перменной перечисляемого типа
	myusb = USB0;							//присваивание ей значения

	enum Boolean { NO, YES };
	enum Boolean flag;

Константы можно создавать с помощью дерективы компилятора #define.

`#define A B` - говорит компилятору заменять A на B. Это один из самых распространненых способов создания именованных констант и один из самых опасных при неловком обращении.

пример:

	#define MAXFLOAT 3.40282347e+38F	//создание константы
	foo = MAXFLOAT;						//применение



## Операторы отношения и логические операторы
 

Иногда данные нужно сравнивать между собой. Для этого используются операторы отношения.


### Операторы отношения

`>` больше

`>=` больше либо равно

`<` меньше

`<=` меньше либо равно

`==` равно

`!=` не равно




### Арифметические операторы

Бинарными (т. е. с двумя операндами) арифметическими операторами являются

`+` сложение

`-` вычитание

`*` умножение

`/` деление

`%` остаток от деления




**Пример**:

	//является ли год високосным?
	//для этого он должен без остатка делиться на 4 и не делится на 100.
	//либо! просто делиться на 400.
	
	(year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)

Оператор `%` к операндам типов `float` и `double` не применяется. В какую сторону (в сторону увеличения или уменьшения числа) будет усечена дробная часть при выполнении `/` и каким будет знак результата операции `%` с отрицательными операндами, зависит от машины.

### Унарный оператор
Кроме бинарных операторов существуют еще и унарные операторы (с одним операндом). Например, `!` -   логическое отрицание, НЕ. Он преобразует ненулевой операнд в 0, а нуль в 1. 

	!(число отличное от нуля) = 0;
	!(0) = 1;


### Приоритет выполнения операторов

Все они имеют одинаковый приоритет. Сразу за ними идет приоритет операторов сравнения на равенство: `==` `!=`. Операторы отношения имеют более низкий приоритет, чем арифметические, поэтому выражение вроде `i < lim-1` будет выполняться так же, как `i < (lim-1)`, т. е. как мы и ожидаем.

Более интересны логические операторы `&&` и `||`. Выражения, между которыми стоят операторы `&&` или `||`, вычисляются слева направо. Вычисление прекращается, как только становится известна истинность или ложность результата.

пример:

	(a == 0) && (b > 10) && (b < 20)
	(a == 0) || (b > 10) || (b < 20)


Бинарные операторы `+` и `-` имеют одинаковый приоритет, который ниже приоритета операторов `*`, `/` и `%`, который в свою очередь ниже приоритета унарных операторов `+` и `-`. Арифметические операции одного приоритетного уровня выполняются слева направо.






## Преобразования типов

Язык Си относится к языкам со `статической` `слабой` `неявной` типизацией. (подробнее, например, [тут](http://habrahabr.ru/post/161205))

В _неявно_ типизированных языках задача определения типа переменной, функции или аргумента может быть спокойно переложена на компилятор или интерпретатор.

Преимущества неявной типизации:

- Удобство использования смешанных выражений (например из целых и вещественных чисел).
- Абстрагирование от типизации и сосредоточение на задаче.
- Краткость записи

пример:
	
	x = 2.098 + 0x34 + 'ы';		\\когда вам нужно сложить что-то,
								\\вы просто берете и складываете их.
								\\а все преобразования типов делает
								\\компилятор, скрывая от вас подробности:

	2.098 + 52.000 + 97.000		\\приведение аргументов к одному типу
	= 151.098					\\суммирование 
	= 151  						\\приведение к типу `x`, например, к int
	
### Целочисленное повышение.
Объект типа перечисление, символ, короткое целое, целое в битовом поле — все они со знаком или без могут использоваться в выражении там, где возможно применение целого. Если тип `int` позволяет "охватить" все значения исходного типа операнда, то операнд приводится к `int`, в противном случае он приводится к `unsigned int`. Эта процедура называется целочисленным повышением.

диапазон значений для short int

+ signed от `-32768` до `+32767`
+ unsigned от `0` до `+65535`


пример:

	#define MAX_INT 32767
	signed short int frq = MAX_INT + 1;		//frq = 32768,
											//переполнения не произошло.
											//автоматическое преобразование повысило
											//signed int до unsigned 


### Арифметические преобразования
Во многих операциях преобразование типов операндов и определение типа результата осуществляются по одним и тем же правилам. Они состоят в том, что *операнды приводятся к некоторому общему типу*, который также  является  и  типом  результата.  Эти  правила  называются  обычными  арифметическими преобразованиями и выглядят достаточно громоздко:

- если один из операндов имеет тип `long double`, то другой приводится к `long double`.
- иначе, если один из операндов имеет тип `double`, то другой приводится к `double`.
- иначе, если один из операндов имеет тип `float`, то другой приводится к `float`.
- иначе для обоих операндов осуществляется  целочисленное повышение; затем, если один из операндов имеет тип `unsigned long int`, той другой преобразуется в `unsigned long int`.
- иначе, если один из операндов принадлежит типу `long int`, а другой — `unsigned int`, то результат зависит от того, покрывает ли `long int` все значения `unsigned int`, и если это так, то `unsigned int`  приводится  к `long int`; если нет, то оба операнда преобразуются в `unsigned long int`.
- иначе, если один из операндов имеет тип `long int`, то другой приводится к `long int`.
- иначе, если один из операндов — `unsigned int`, то другой приводится к `unsigned int`.
- иначе оба операнда имеют тип `int`.

пример:
	
	int + char = int			//тип операндов и тип результата 
	int + double = double
	float + double = double

если грубо, то из двух типов выбирается наиболее вместительный.
	 
	



### Целые и числа с плавающей точкой
При преобразовании из типа с плавающей точкой в целочисленный дробная часть значения отбрасывается. 

* Если полученное при этом значение нельзя представить в заданном целочисленном типе, то результат не определен. Например, не определен результат преобразования отрицательных значений с плавающей точкой в беззнаковые целые.

* Если значение преобразуется из целого в величину с плавающей точкой и она находится в допустимом диапазоне, но представляется в новом типе неточно, то результатом будет одно из двух значений нового типа,  ближайших  к  исходному.
 
* Если  результат  выходит  за  границы  диапазона  допустимых  значений, поведение программы не определено.

пример
	
	int d;
	d = -2.81;				//результат не определен, -2? -3?
	d = 15.00099999e+3;		//результат не определен, 15000? 15001?
	d = 1e+10;				//warning: overflow, 32767?



## Операторы инкремента и декремента
В Си есть два необычных оператора, предназначенных для увеличения и уменьшения переменных. Оператор инкремента ++ добавляет 1 к своему операнду, а оператор декремента -- вычитает 1.

пример:

	a = a + 1;		//полная версия
	a++;			//сокращенная, постфиксная

Необычность операторов ++ и -- в том, что их можно использовать и как префиксные (помещая перед переменной: ++n), и как постфиксные (помещая после переменной: n++) операторы. В обоих случаях значение n увеличивается на 1, но выражение ++n увеличивает n до того, как его значение будет использовано, а n++ — после того

пример:

	x = a;			//сначала присвоили
	a = a + 1;		//потом увеличили
	x = a++;		//эквивалентная постфиксная запись

	a = a + 1;		//сначала увеличили
	x = a;			//потом присвоили
	x = ++a;		//эквивалентная префиксная запись

	a[n]= 0;		//запись нуля в элемент массива под номером n
	n++;			//изменение номера элемента на n+1
	a[n++] = 0;		//эквивалентная постфиксная запись



### Побитовые операторы

В  Си  имеются  шесть  операторов  для  манипулирования  с  битами.  Их  можно  применять  только  к целочисленным операндам, т. е. к операндам типов char, short, int и long, знаковым и беззнаковым.

	`&`  побитовое И.
	`|`  побитовое ИЛИ.
	`^`  побитовое исключающее ИЛИ.
	`<<` сдвиг влево.
	`>>` сдвиг вправо.
	`~`  побитовое отрицание (унарный).

Оператор `&` (побитовое И) часто используется для обнуления некоторой группы разрядов.

пример:

	n = n & 0x3;		//обнуляем в n все разряды, кроме младших двух. тк 0x3 = 0011

Оператор `|` (побитовое ИЛИ) применяют для установки разрядов.

пример:

	х = х | SET_ON;		//устанавливаем единицы в тех разрядах x,
						//которым соответствуют единицы в SET_ON.

Оператор `^` (побитовое исключающее ИЛИ) в каждом разряде установит 1, если соответствующие разряды операндов имеют различные значения, и 0, когда они совпадают.

Поразрядные операторы `&` и `|` следует отличать от логических операторов `&&` и `||`, которые при вычислении слева направо дают значение истинности. Например, если x равно 1, а y равно 2, то x & y даст нуль, а x && у единицу.

Операторы `<<` и `>>` сдвигают влево или вправо свой левый операнд на число битовых позиций, задаваемое правым операндом, который должен быть неотрицательным.

пример:

	х << n;			//сдвигаем значение х влево на n позиций,
					//заполняя освобождающиеся биты нулями
					//(при условии что x не отрицательно),
					//что эквивалентно умножению х  на 2^n
	

Унарный оператор `~` поразрядно инвертирует биты.

пример:

	char х = ~0xF0

пример:

	//задача: подсчет в переменной `x` бит равных "1"
	//до тех пор пока (x != 0)
	//сдвигаем x на один бит вправо (x = x >> 1)
	//если (x & 01) == 1
	//увеличиваем число бит на один

	1:  x = 0xA;       //начальное состояние (x = 0xA = 101)
	2:  x & 1 = ? ;    //проверяем младший бит (101 & 1 == 1) ?
	3:  n++;           //увеличиваем число бит на один
	4:  x = x >> 1;    //сдвигаем х на один вправо
	5:  x == 0 ?       //кончились биты (x = 0x0 = 000) ?
                       //повторяем пункты 2,3,4,5



### Операторы и выражения присваивания
Большинству бинарных операторов (типа `+` и имеющих левый и правый операнды) соответствуют операторы присваивания `ор=`, где _ор_ — один из операторов (`+`  `*`  `/`  `%`  `<<`  `>>`  `&`  `^`  `|` )
Зачастую это облегчает чтение кода программы.

	a = a op b
	a op= b

пример:

	yyval[yypv[p3+p4] + yypv[p1+p2]] += 2;
	читателю при не потребуется старательно сравнивать два длинных выражения.



### Условные выражения

иногда выражения вида

	if (a)	b;
	else 	c;

удобно записать сокращенно

	a ? b : c

пример:

	print ((i%10 == 9 || i == n-1) ? 'n' : ' ');



### Приоритет и очередность вычислений
Приоритеты
Существует таблица приоритетов и очередностей вычислений всех операторов, включая и те, которые мы еще не рассматривали. Но не будем на ней подробно останавливаться.

Очередность
Си подобно многим языкам не фиксирует очередность вычисления операндов оператора. За исключением `&&`, `||`, `?:` и `,`.

пример:
	
	х = f() + g(); 	//f может быть вычислена раньше g или наоборот.
					//Из этого следует, что  если одна из функций изменяет
					//значение переменной, от которой зависит другая функция,
					//то помещаемый в x результат может зависеть от очередности
					//вычислений. Чтобы  обеспечить  нужную
					//последовательность вычислений,  промежуточные результаты
					//можно запоминать во временных переменных.
	
	x1 = f();		//вариант с предсказуемой последовательсностью вычислений
	x2 = g();
	x = x1 + x2;

Кроме того обращения к функциям, вложенные присвоения, инкрементные и декрементные операторы дают "побочный эффект",  проявляющийся  в  том,  что  при  вычислении  выражения  значения  некоторых  переменных изменяются. В любом выражении с побочным эффектом может быть скрыта трудно просматриваемая зависимость  результата  выражения  от  очередности  изменения  значений  переменных,  входящих  в выражение.

пример:

	foo(++n, power(2,n));	//Очередность вычисления аргументов функции
							//также не определена, поэтому на разных
							//компиляторах может давать несовпадающие
							//результаты. Результат вызова функции
							//зависит от того, когда компилятор
							//сгенерирует команды увеличения n —
							//до или после обращения к power.
	
	++n;					//лучше так
	foo (n, power(2,n));

пример:

	a[i] = i++;				//массив "a" индексируется старым или
							//измененным значением i?

	a[i] = i;				//лучше так
	i++;



Стандарт языка С сознательно устроен так, что большинство подобных вопросов оставлено на усмотрение компиляторов, так как лучший порядок  вычислений  определяется  архитектурой  машины. Стандартом  только  гарантируется,  что  все побочные эффекты при вычислении аргументов проявятся перед входом в функцию. Правда, нам это уже не поможет.

совет : какой бы язык вы ни использовали, пишите программы, не зависящие от очередности вычислений.



















